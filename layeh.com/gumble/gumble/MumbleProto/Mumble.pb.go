// Code generated by protoc-gen-go.
// source: Mumble.proto
// DO NOT EDIT!

/*
Package MumbleProto is a generated protocol buffer package.

It is generated from these files:
	Mumble.proto

It has these top-level messages:
	Version
	UDPTunnel
	Authenticate
	Ping
	Reject
	ServerSync
	ChannelRemove
	ChannelState
	UserRemove
	UserState
	BanList
	TextMessage
	PermissionDenied
	ACL
	QueryUsers
	CryptSetup
	ContextActionModify
	ContextAction
	UserList
	VoiceTarget
	PermissionQuery
	CodecVersion
	UserStats
	RequestBlob
	ServerConfig
	SuggestConfig
*/
package MumbleProto // import "layeh.com/gumble/gumble/MumbleProto"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Reject_RejectType int32

const (
	// The rejection reason is unknown (details should be available
	// in Reject.reason).
	Reject_None Reject_RejectType = 0
	// The client attempted to connect with an incompatible version.
	Reject_WrongVersion Reject_RejectType = 1
	// The user name supplied by the client was invalid.
	Reject_InvalidUsername Reject_RejectType = 2
	// The client attempted to authenticate as a user with a password but it
	// was wrong.
	Reject_WrongUserPW Reject_RejectType = 3
	// The client attempted to connect to a passworded server but the password
	// was wrong.
	Reject_WrongServerPW Reject_RejectType = 4
	// Supplied username is already in use.
	Reject_UsernameInUse Reject_RejectType = 5
	// Server is currently full and cannot accept more users.
	Reject_ServerFull Reject_RejectType = 6
	// The user did not provide a certificate but one is required.
	Reject_NoCertificate     Reject_RejectType = 7
	Reject_AuthenticatorFail Reject_RejectType = 8
)

var Reject_RejectType_name = map[int32]string{
	0: "None",
	1: "WrongVersion",
	2: "InvalidUsername",
	3: "WrongUserPW",
	4: "WrongServerPW",
	5: "UsernameInUse",
	6: "ServerFull",
	7: "NoCertificate",
	8: "AuthenticatorFail",
}
var Reject_RejectType_value = map[string]int32{
	"None":              0,
	"WrongVersion":      1,
	"InvalidUsername":   2,
	"WrongUserPW":       3,
	"WrongServerPW":     4,
	"UsernameInUse":     5,
	"ServerFull":        6,
	"NoCertificate":     7,
	"AuthenticatorFail": 8,
}

func (x Reject_RejectType) Enum() *Reject_RejectType {
	p := new(Reject_RejectType)
	*p = x
	return p
}
func (x Reject_RejectType) String() string {
	return proto.EnumName(Reject_RejectType_name, int32(x))
}
func (x *Reject_RejectType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Reject_RejectType_value, data, "Reject_RejectType")
	if err != nil {
		return err
	}
	*x = Reject_RejectType(value)
	return nil
}
func (Reject_RejectType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

type PermissionDenied_DenyType int32

const (
	// Operation denied for other reason, see reason field.
	PermissionDenied_Text PermissionDenied_DenyType = 0
	// Permissions were denied.
	PermissionDenied_Permission PermissionDenied_DenyType = 1
	// Cannot modify SuperUser.
	PermissionDenied_SuperUser PermissionDenied_DenyType = 2
	// Invalid channel name.
	PermissionDenied_ChannelName PermissionDenied_DenyType = 3
	// Text message too long.
	PermissionDenied_TextTooLong PermissionDenied_DenyType = 4
	// The flux capacitor was spelled wrong.
	PermissionDenied_H9K PermissionDenied_DenyType = 5
	// Operation not permitted in temporary channel.
	PermissionDenied_TemporaryChannel PermissionDenied_DenyType = 6
	// Operation requires certificate.
	PermissionDenied_MissingCertificate PermissionDenied_DenyType = 7
	// Invalid username.
	PermissionDenied_UserName PermissionDenied_DenyType = 8
	// Channel is full.
	PermissionDenied_ChannelFull  PermissionDenied_DenyType = 9
	PermissionDenied_NestingLimit PermissionDenied_DenyType = 10
)

var PermissionDenied_DenyType_name = map[int32]string{
	0:  "Text",
	1:  "Permission",
	2:  "SuperUser",
	3:  "ChannelName",
	4:  "TextTooLong",
	5:  "H9K",
	6:  "TemporaryChannel",
	7:  "MissingCertificate",
	8:  "UserName",
	9:  "ChannelFull",
	10: "NestingLimit",
}
var PermissionDenied_DenyType_value = map[string]int32{
	"Text":               0,
	"Permission":         1,
	"SuperUser":          2,
	"ChannelName":        3,
	"TextTooLong":        4,
	"H9K":                5,
	"TemporaryChannel":   6,
	"MissingCertificate": 7,
	"UserName":           8,
	"ChannelFull":        9,
	"NestingLimit":       10,
}

func (x PermissionDenied_DenyType) Enum() *PermissionDenied_DenyType {
	p := new(PermissionDenied_DenyType)
	*p = x
	return p
}
func (x PermissionDenied_DenyType) String() string {
	return proto.EnumName(PermissionDenied_DenyType_name, int32(x))
}
func (x *PermissionDenied_DenyType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(PermissionDenied_DenyType_value, data, "PermissionDenied_DenyType")
	if err != nil {
		return err
	}
	*x = PermissionDenied_DenyType(value)
	return nil
}
func (PermissionDenied_DenyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{12, 0}
}

type ContextActionModify_Context int32

const (
	// Action is applicable to the server.
	ContextActionModify_Server ContextActionModify_Context = 1
	// Action can target a Channel.
	ContextActionModify_Channel ContextActionModify_Context = 2
	// Action can target a User.
	ContextActionModify_User ContextActionModify_Context = 4
)

var ContextActionModify_Context_name = map[int32]string{
	1: "Server",
	2: "Channel",
	4: "User",
}
var ContextActionModify_Context_value = map[string]int32{
	"Server":  1,
	"Channel": 2,
	"User":    4,
}

func (x ContextActionModify_Context) Enum() *ContextActionModify_Context {
	p := new(ContextActionModify_Context)
	*p = x
	return p
}
func (x ContextActionModify_Context) String() string {
	return proto.EnumName(ContextActionModify_Context_name, int32(x))
}
func (x *ContextActionModify_Context) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ContextActionModify_Context_value, data, "ContextActionModify_Context")
	if err != nil {
		return err
	}
	*x = ContextActionModify_Context(value)
	return nil
}
func (ContextActionModify_Context) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{16, 0}
}

type ContextActionModify_Operation int32

const (
	ContextActionModify_Add    ContextActionModify_Operation = 0
	ContextActionModify_Remove ContextActionModify_Operation = 1
)

var ContextActionModify_Operation_name = map[int32]string{
	0: "Add",
	1: "Remove",
}
var ContextActionModify_Operation_value = map[string]int32{
	"Add":    0,
	"Remove": 1,
}

func (x ContextActionModify_Operation) Enum() *ContextActionModify_Operation {
	p := new(ContextActionModify_Operation)
	*p = x
	return p
}
func (x ContextActionModify_Operation) String() string {
	return proto.EnumName(ContextActionModify_Operation_name, int32(x))
}
func (x *ContextActionModify_Operation) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ContextActionModify_Operation_value, data, "ContextActionModify_Operation")
	if err != nil {
		return err
	}
	*x = ContextActionModify_Operation(value)
	return nil
}
func (ContextActionModify_Operation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{16, 1}
}

type Version struct {
	// 2-byte Major, 1-byte Minor and 1-byte Patch version number.
	Version *uint32 `protobuf:"varint,1,opt,name=version" json:"version,omitempty"`
	// Client release name.
	Release *string `protobuf:"bytes,2,opt,name=release" json:"release,omitempty"`
	// Client OS name.
	Os *string `protobuf:"bytes,3,opt,name=os" json:"os,omitempty"`
	// Client OS version.
	OsVersion        *string `protobuf:"bytes,4,opt,name=os_version,json=osVersion" json:"os_version,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Version) Reset()                    { *m = Version{} }
func (m *Version) String() string            { return proto.CompactTextString(m) }
func (*Version) ProtoMessage()               {}
func (*Version) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Version) GetVersion() uint32 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

func (m *Version) GetRelease() string {
	if m != nil && m.Release != nil {
		return *m.Release
	}
	return ""
}

func (m *Version) GetOs() string {
	if m != nil && m.Os != nil {
		return *m.Os
	}
	return ""
}

func (m *Version) GetOsVersion() string {
	if m != nil && m.OsVersion != nil {
		return *m.OsVersion
	}
	return ""
}

// Not used. Not even for tunneling UDP through TCP.
type UDPTunnel struct {
	// Not used.
	Packet           []byte `protobuf:"bytes,1,req,name=packet" json:"packet,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *UDPTunnel) Reset()                    { *m = UDPTunnel{} }
func (m *UDPTunnel) String() string            { return proto.CompactTextString(m) }
func (*UDPTunnel) ProtoMessage()               {}
func (*UDPTunnel) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *UDPTunnel) GetPacket() []byte {
	if m != nil {
		return m.Packet
	}
	return nil
}

// Used by the client to send the authentication credentials to the server.
type Authenticate struct {
	// UTF-8 encoded username.
	Username *string `protobuf:"bytes,1,opt,name=username" json:"username,omitempty"`
	// Server or user password.
	Password *string `protobuf:"bytes,2,opt,name=password" json:"password,omitempty"`
	// Additional access tokens for server ACL groups.
	Tokens []string `protobuf:"bytes,3,rep,name=tokens" json:"tokens,omitempty"`
	// A list of CELT bitstream version constants supported by the client.
	CeltVersions     []int32 `protobuf:"varint,4,rep,name=celt_versions,json=celtVersions" json:"celt_versions,omitempty"`
	Opus             *bool   `protobuf:"varint,5,opt,name=opus,def=0" json:"opus,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Authenticate) Reset()                    { *m = Authenticate{} }
func (m *Authenticate) String() string            { return proto.CompactTextString(m) }
func (*Authenticate) ProtoMessage()               {}
func (*Authenticate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

const Default_Authenticate_Opus bool = false

func (m *Authenticate) GetUsername() string {
	if m != nil && m.Username != nil {
		return *m.Username
	}
	return ""
}

func (m *Authenticate) GetPassword() string {
	if m != nil && m.Password != nil {
		return *m.Password
	}
	return ""
}

func (m *Authenticate) GetTokens() []string {
	if m != nil {
		return m.Tokens
	}
	return nil
}

func (m *Authenticate) GetCeltVersions() []int32 {
	if m != nil {
		return m.CeltVersions
	}
	return nil
}

func (m *Authenticate) GetOpus() bool {
	if m != nil && m.Opus != nil {
		return *m.Opus
	}
	return Default_Authenticate_Opus
}

// Sent by the client to notify the server that the client is still alive.
// Server must reply to the packet with the same timestamp and its own
// good/late/lost/resync numbers. None of the fields is strictly required.
type Ping struct {
	// Client timestamp. Server should not attempt to decode.
	Timestamp *uint64 `protobuf:"varint,1,opt,name=timestamp" json:"timestamp,omitempty"`
	// The amount of good packets received.
	Good *uint32 `protobuf:"varint,2,opt,name=good" json:"good,omitempty"`
	// The amount of late packets received.
	Late *uint32 `protobuf:"varint,3,opt,name=late" json:"late,omitempty"`
	// The amount of packets never received.
	Lost *uint32 `protobuf:"varint,4,opt,name=lost" json:"lost,omitempty"`
	// The amount of nonce resyncs.
	Resync *uint32 `protobuf:"varint,5,opt,name=resync" json:"resync,omitempty"`
	// The total amount of UDP packets received.
	UdpPackets *uint32 `protobuf:"varint,6,opt,name=udp_packets,json=udpPackets" json:"udp_packets,omitempty"`
	// The total amount of TCP packets received.
	TcpPackets *uint32 `protobuf:"varint,7,opt,name=tcp_packets,json=tcpPackets" json:"tcp_packets,omitempty"`
	// UDP ping average.
	UdpPingAvg *float32 `protobuf:"fixed32,8,opt,name=udp_ping_avg,json=udpPingAvg" json:"udp_ping_avg,omitempty"`
	// UDP ping variance.
	UdpPingVar *float32 `protobuf:"fixed32,9,opt,name=udp_ping_var,json=udpPingVar" json:"udp_ping_var,omitempty"`
	// TCP ping average.
	TcpPingAvg *float32 `protobuf:"fixed32,10,opt,name=tcp_ping_avg,json=tcpPingAvg" json:"tcp_ping_avg,omitempty"`
	// TCP ping variance.
	TcpPingVar       *float32 `protobuf:"fixed32,11,opt,name=tcp_ping_var,json=tcpPingVar" json:"tcp_ping_var,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Ping) Reset()                    { *m = Ping{} }
func (m *Ping) String() string            { return proto.CompactTextString(m) }
func (*Ping) ProtoMessage()               {}
func (*Ping) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Ping) GetTimestamp() uint64 {
	if m != nil && m.Timestamp != nil {
		return *m.Timestamp
	}
	return 0
}

func (m *Ping) GetGood() uint32 {
	if m != nil && m.Good != nil {
		return *m.Good
	}
	return 0
}

func (m *Ping) GetLate() uint32 {
	if m != nil && m.Late != nil {
		return *m.Late
	}
	return 0
}

func (m *Ping) GetLost() uint32 {
	if m != nil && m.Lost != nil {
		return *m.Lost
	}
	return 0
}

func (m *Ping) GetResync() uint32 {
	if m != nil && m.Resync != nil {
		return *m.Resync
	}
	return 0
}

func (m *Ping) GetUdpPackets() uint32 {
	if m != nil && m.UdpPackets != nil {
		return *m.UdpPackets
	}
	return 0
}

func (m *Ping) GetTcpPackets() uint32 {
	if m != nil && m.TcpPackets != nil {
		return *m.TcpPackets
	}
	return 0
}

func (m *Ping) GetUdpPingAvg() float32 {
	if m != nil && m.UdpPingAvg != nil {
		return *m.UdpPingAvg
	}
	return 0
}

func (m *Ping) GetUdpPingVar() float32 {
	if m != nil && m.UdpPingVar != nil {
		return *m.UdpPingVar
	}
	return 0
}

func (m *Ping) GetTcpPingAvg() float32 {
	if m != nil && m.TcpPingAvg != nil {
		return *m.TcpPingAvg
	}
	return 0
}

func (m *Ping) GetTcpPingVar() float32 {
	if m != nil && m.TcpPingVar != nil {
		return *m.TcpPingVar
	}
	return 0
}

// Sent by the server when it rejects the user connection.
type Reject struct {
	// Rejection type.
	Type *Reject_RejectType `protobuf:"varint,1,opt,name=type,enum=MumbleProto.Reject_RejectType" json:"type,omitempty"`
	// Human readable rejection reason.
	Reason           *string `protobuf:"bytes,2,opt,name=reason" json:"reason,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Reject) Reset()                    { *m = Reject{} }
func (m *Reject) String() string            { return proto.CompactTextString(m) }
func (*Reject) ProtoMessage()               {}
func (*Reject) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Reject) GetType() Reject_RejectType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Reject_None
}

func (m *Reject) GetReason() string {
	if m != nil && m.Reason != nil {
		return *m.Reason
	}
	return ""
}

// ServerSync message is sent by the server when it has authenticated the user
// and finished synchronizing the server state.
type ServerSync struct {
	// The session of the current user.
	Session *uint32 `protobuf:"varint,1,opt,name=session" json:"session,omitempty"`
	// Maximum bandwidth that the user should use.
	MaxBandwidth *uint32 `protobuf:"varint,2,opt,name=max_bandwidth,json=maxBandwidth" json:"max_bandwidth,omitempty"`
	// Server welcome text.
	WelcomeText *string `protobuf:"bytes,3,opt,name=welcome_text,json=welcomeText" json:"welcome_text,omitempty"`
	// Current user permissions in the root channel.
	Permissions      *uint64 `protobuf:"varint,4,opt,name=permissions" json:"permissions,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ServerSync) Reset()                    { *m = ServerSync{} }
func (m *ServerSync) String() string            { return proto.CompactTextString(m) }
func (*ServerSync) ProtoMessage()               {}
func (*ServerSync) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ServerSync) GetSession() uint32 {
	if m != nil && m.Session != nil {
		return *m.Session
	}
	return 0
}

func (m *ServerSync) GetMaxBandwidth() uint32 {
	if m != nil && m.MaxBandwidth != nil {
		return *m.MaxBandwidth
	}
	return 0
}

func (m *ServerSync) GetWelcomeText() string {
	if m != nil && m.WelcomeText != nil {
		return *m.WelcomeText
	}
	return ""
}

func (m *ServerSync) GetPermissions() uint64 {
	if m != nil && m.Permissions != nil {
		return *m.Permissions
	}
	return 0
}

// Sent by the client when it wants a channel removed. Sent by the server when
// a channel has been removed and clients should be notified.
type ChannelRemove struct {
	ChannelId        *uint32 `protobuf:"varint,1,req,name=channel_id,json=channelId" json:"channel_id,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ChannelRemove) Reset()                    { *m = ChannelRemove{} }
func (m *ChannelRemove) String() string            { return proto.CompactTextString(m) }
func (*ChannelRemove) ProtoMessage()               {}
func (*ChannelRemove) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ChannelRemove) GetChannelId() uint32 {
	if m != nil && m.ChannelId != nil {
		return *m.ChannelId
	}
	return 0
}

// Used to communicate channel properties between the client and the server.
// Sent by the server during the login process or when channel properties are
// updated. Client may use this message to update said channel properties.
type ChannelState struct {
	// Unique ID for the channel within the server.
	ChannelId *uint32 `protobuf:"varint,1,opt,name=channel_id,json=channelId" json:"channel_id,omitempty"`
	// channel_id of the parent channel.
	Parent *uint32 `protobuf:"varint,2,opt,name=parent" json:"parent,omitempty"`
	// UTF-8 encoded channel name.
	Name *string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	// A collection of channel id values of the linked channels. Absent during
	// the first channel listing.
	Links []uint32 `protobuf:"varint,4,rep,name=links" json:"links,omitempty"`
	// UTF-8 encoded channel description. Only if the description is less than
	// 128 bytes
	Description *string `protobuf:"bytes,5,opt,name=description" json:"description,omitempty"`
	// A collection of channel_id values that should be added to links.
	LinksAdd []uint32 `protobuf:"varint,6,rep,name=links_add,json=linksAdd" json:"links_add,omitempty"`
	// A collection of channel_id values that should be removed from links.
	LinksRemove []uint32 `protobuf:"varint,7,rep,name=links_remove,json=linksRemove" json:"links_remove,omitempty"`
	// True if the channel is temporary.
	Temporary *bool `protobuf:"varint,8,opt,name=temporary,def=0" json:"temporary,omitempty"`
	// Position weight to tweak the channel position in the channel list.
	Position *int32 `protobuf:"varint,9,opt,name=position,def=0" json:"position,omitempty"`
	// SHA1 hash of the description if the description is 128 bytes or more.
	DescriptionHash []byte `protobuf:"bytes,10,opt,name=description_hash,json=descriptionHash" json:"description_hash,omitempty"`
	// Maximum number of users allowed in the channel. If this value is zero,
	// the maximum number of users allowed in the channel is given by the
	// server's "usersperchannel" setting.
	MaxUsers         *uint32 `protobuf:"varint,11,opt,name=max_users,json=maxUsers" json:"max_users,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ChannelState) Reset()                    { *m = ChannelState{} }
func (m *ChannelState) String() string            { return proto.CompactTextString(m) }
func (*ChannelState) ProtoMessage()               {}
func (*ChannelState) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

const Default_ChannelState_Temporary bool = false
const Default_ChannelState_Position int32 = 0

func (m *ChannelState) GetChannelId() uint32 {
	if m != nil && m.ChannelId != nil {
		return *m.ChannelId
	}
	return 0
}

func (m *ChannelState) GetParent() uint32 {
	if m != nil && m.Parent != nil {
		return *m.Parent
	}
	return 0
}

func (m *ChannelState) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ChannelState) GetLinks() []uint32 {
	if m != nil {
		return m.Links
	}
	return nil
}

func (m *ChannelState) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

func (m *ChannelState) GetLinksAdd() []uint32 {
	if m != nil {
		return m.LinksAdd
	}
	return nil
}

func (m *ChannelState) GetLinksRemove() []uint32 {
	if m != nil {
		return m.LinksRemove
	}
	return nil
}

func (m *ChannelState) GetTemporary() bool {
	if m != nil && m.Temporary != nil {
		return *m.Temporary
	}
	return Default_ChannelState_Temporary
}

func (m *ChannelState) GetPosition() int32 {
	if m != nil && m.Position != nil {
		return *m.Position
	}
	return Default_ChannelState_Position
}

func (m *ChannelState) GetDescriptionHash() []byte {
	if m != nil {
		return m.DescriptionHash
	}
	return nil
}

func (m *ChannelState) GetMaxUsers() uint32 {
	if m != nil && m.MaxUsers != nil {
		return *m.MaxUsers
	}
	return 0
}

// Used to communicate user leaving or being kicked. May be sent by the client
// when it attempts to kick a user. Sent by the server when it informs the
// clients that a user is not present anymore.
type UserRemove struct {
	// The user who is being kicked, identified by their session, not present
	// when no one is being kicked.
	Session *uint32 `protobuf:"varint,1,req,name=session" json:"session,omitempty"`
	// The user who initiated the removal. Either the user who performs the kick
	// or the user who is currently leaving.
	Actor *uint32 `protobuf:"varint,2,opt,name=actor" json:"actor,omitempty"`
	// Reason for the kick, stored as the ban reason if the user is banned.
	Reason *string `protobuf:"bytes,3,opt,name=reason" json:"reason,omitempty"`
	// True if the kick should result in a ban.
	Ban              *bool  `protobuf:"varint,4,opt,name=ban" json:"ban,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *UserRemove) Reset()                    { *m = UserRemove{} }
func (m *UserRemove) String() string            { return proto.CompactTextString(m) }
func (*UserRemove) ProtoMessage()               {}
func (*UserRemove) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *UserRemove) GetSession() uint32 {
	if m != nil && m.Session != nil {
		return *m.Session
	}
	return 0
}

func (m *UserRemove) GetActor() uint32 {
	if m != nil && m.Actor != nil {
		return *m.Actor
	}
	return 0
}

func (m *UserRemove) GetReason() string {
	if m != nil && m.Reason != nil {
		return *m.Reason
	}
	return ""
}

func (m *UserRemove) GetBan() bool {
	if m != nil && m.Ban != nil {
		return *m.Ban
	}
	return false
}

// Sent by the server when it communicates new and changed users to client.
// First seen during login procedure. May be sent by the client when it wishes
// to alter its state.
type UserState struct {
	// Unique user session ID of the user whose state this is, may change on
	// reconnect.
	Session *uint32 `protobuf:"varint,1,opt,name=session" json:"session,omitempty"`
	// The session of the user who is updating this user.
	Actor *uint32 `protobuf:"varint,2,opt,name=actor" json:"actor,omitempty"`
	// User name, UTF-8 encoded.
	Name *string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	// Registered user ID if the user is registered.
	UserId *uint32 `protobuf:"varint,4,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	// Channel on which the user is.
	ChannelId *uint32 `protobuf:"varint,5,opt,name=channel_id,json=channelId" json:"channel_id,omitempty"`
	// True if the user is muted by admin.
	Mute *bool `protobuf:"varint,6,opt,name=mute" json:"mute,omitempty"`
	// True if the user is deafened by admin.
	Deaf *bool `protobuf:"varint,7,opt,name=deaf" json:"deaf,omitempty"`
	// True if the user has been suppressed from talking by a reason other than
	// being muted.
	Suppress *bool `protobuf:"varint,8,opt,name=suppress" json:"suppress,omitempty"`
	// True if the user has muted self.
	SelfMute *bool `protobuf:"varint,9,opt,name=self_mute,json=selfMute" json:"self_mute,omitempty"`
	// True if the user has deafened self.
	SelfDeaf *bool `protobuf:"varint,10,opt,name=self_deaf,json=selfDeaf" json:"self_deaf,omitempty"`
	// User image if it is less than 128 bytes.
	Texture []byte `protobuf:"bytes,11,opt,name=texture" json:"texture,omitempty"`
	// The positional audio plugin identifier.
	// Positional audio information is only sent to users who share
	// identical plugin contexts.
	//
	// This value is not trasmitted to clients.
	PluginContext []byte `protobuf:"bytes,12,opt,name=plugin_context,json=pluginContext" json:"plugin_context,omitempty"`
	// The user's plugin-specific identity.
	// This value is not transmitted to clients.
	PluginIdentity *string `protobuf:"bytes,13,opt,name=plugin_identity,json=pluginIdentity" json:"plugin_identity,omitempty"`
	// User comment if it is less than 128 bytes.
	Comment *string `protobuf:"bytes,14,opt,name=comment" json:"comment,omitempty"`
	// The hash of the user certificate.
	Hash *string `protobuf:"bytes,15,opt,name=hash" json:"hash,omitempty"`
	// SHA1 hash of the user comment if it 128 bytes or more.
	CommentHash []byte `protobuf:"bytes,16,opt,name=comment_hash,json=commentHash" json:"comment_hash,omitempty"`
	// SHA1 hash of the user picture if it 128 bytes or more.
	TextureHash []byte `protobuf:"bytes,17,opt,name=texture_hash,json=textureHash" json:"texture_hash,omitempty"`
	// True if the user is a priority speaker.
	PrioritySpeaker *bool `protobuf:"varint,18,opt,name=priority_speaker,json=prioritySpeaker" json:"priority_speaker,omitempty"`
	// True if the user is currently recording.
	Recording        *bool  `protobuf:"varint,19,opt,name=recording" json:"recording,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *UserState) Reset()                    { *m = UserState{} }
func (m *UserState) String() string            { return proto.CompactTextString(m) }
func (*UserState) ProtoMessage()               {}
func (*UserState) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *UserState) GetSession() uint32 {
	if m != nil && m.Session != nil {
		return *m.Session
	}
	return 0
}

func (m *UserState) GetActor() uint32 {
	if m != nil && m.Actor != nil {
		return *m.Actor
	}
	return 0
}

func (m *UserState) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *UserState) GetUserId() uint32 {
	if m != nil && m.UserId != nil {
		return *m.UserId
	}
	return 0
}

func (m *UserState) GetChannelId() uint32 {
	if m != nil && m.ChannelId != nil {
		return *m.ChannelId
	}
	return 0
}

func (m *UserState) GetMute() bool {
	if m != nil && m.Mute != nil {
		return *m.Mute
	}
	return false
}

func (m *UserState) GetDeaf() bool {
	if m != nil && m.Deaf != nil {
		return *m.Deaf
	}
	return false
}

func (m *UserState) GetSuppress() bool {
	if m != nil && m.Suppress != nil {
		return *m.Suppress
	}
	return false
}

func (m *UserState) GetSelfMute() bool {
	if m != nil && m.SelfMute != nil {
		return *m.SelfMute
	}
	return false
}

func (m *UserState) GetSelfDeaf() bool {
	if m != nil && m.SelfDeaf != nil {
		return *m.SelfDeaf
	}
	return false
}

func (m *UserState) GetTexture() []byte {
	if m != nil {
		return m.Texture
	}
	return nil
}

func (m *UserState) GetPluginContext() []byte {
	if m != nil {
		return m.PluginContext
	}
	return nil
}

func (m *UserState) GetPluginIdentity() string {
	if m != nil && m.PluginIdentity != nil {
		return *m.PluginIdentity
	}
	return ""
}

func (m *UserState) GetComment() string {
	if m != nil && m.Comment != nil {
		return *m.Comment
	}
	return ""
}

func (m *UserState) GetHash() string {
	if m != nil && m.Hash != nil {
		return *m.Hash
	}
	return ""
}

func (m *UserState) GetCommentHash() []byte {
	if m != nil {
		return m.CommentHash
	}
	return nil
}

func (m *UserState) GetTextureHash() []byte {
	if m != nil {
		return m.TextureHash
	}
	return nil
}

func (m *UserState) GetPrioritySpeaker() bool {
	if m != nil && m.PrioritySpeaker != nil {
		return *m.PrioritySpeaker
	}
	return false
}

func (m *UserState) GetRecording() bool {
	if m != nil && m.Recording != nil {
		return *m.Recording
	}
	return false
}

// Relays information on the bans. The client may send the BanList message to
// either modify the list of bans or query them from the server. The server
// sends this list only after a client queries for it.
type BanList struct {
	// List of ban entries currently in place.
	Bans []*BanList_BanEntry `protobuf:"bytes,1,rep,name=bans" json:"bans,omitempty"`
	// True if the server should return the list, false if it should replace old
	// ban list with the one provided.
	Query            *bool  `protobuf:"varint,2,opt,name=query,def=0" json:"query,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *BanList) Reset()                    { *m = BanList{} }
func (m *BanList) String() string            { return proto.CompactTextString(m) }
func (*BanList) ProtoMessage()               {}
func (*BanList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

const Default_BanList_Query bool = false

func (m *BanList) GetBans() []*BanList_BanEntry {
	if m != nil {
		return m.Bans
	}
	return nil
}

func (m *BanList) GetQuery() bool {
	if m != nil && m.Query != nil {
		return *m.Query
	}
	return Default_BanList_Query
}

type BanList_BanEntry struct {
	// Banned IP address.
	Address []byte `protobuf:"bytes,1,req,name=address" json:"address,omitempty"`
	// The length of the subnet mask for the ban.
	Mask *uint32 `protobuf:"varint,2,req,name=mask" json:"mask,omitempty"`
	// User name for identification purposes (does not affect the ban).
	Name *string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	// The certificate hash of the banned user.
	Hash *string `protobuf:"bytes,4,opt,name=hash" json:"hash,omitempty"`
	// Reason for the ban (does not affect the ban).
	Reason *string `protobuf:"bytes,5,opt,name=reason" json:"reason,omitempty"`
	// Ban start time.
	Start *string `protobuf:"bytes,6,opt,name=start" json:"start,omitempty"`
	// Ban duration in seconds.
	Duration         *uint32 `protobuf:"varint,7,opt,name=duration" json:"duration,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *BanList_BanEntry) Reset()                    { *m = BanList_BanEntry{} }
func (m *BanList_BanEntry) String() string            { return proto.CompactTextString(m) }
func (*BanList_BanEntry) ProtoMessage()               {}
func (*BanList_BanEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 0} }

func (m *BanList_BanEntry) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *BanList_BanEntry) GetMask() uint32 {
	if m != nil && m.Mask != nil {
		return *m.Mask
	}
	return 0
}

func (m *BanList_BanEntry) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *BanList_BanEntry) GetHash() string {
	if m != nil && m.Hash != nil {
		return *m.Hash
	}
	return ""
}

func (m *BanList_BanEntry) GetReason() string {
	if m != nil && m.Reason != nil {
		return *m.Reason
	}
	return ""
}

func (m *BanList_BanEntry) GetStart() string {
	if m != nil && m.Start != nil {
		return *m.Start
	}
	return ""
}

func (m *BanList_BanEntry) GetDuration() uint32 {
	if m != nil && m.Duration != nil {
		return *m.Duration
	}
	return 0
}

// Used to send and broadcast text messages.
type TextMessage struct {
	// The message sender, identified by its session.
	Actor *uint32 `protobuf:"varint,1,opt,name=actor" json:"actor,omitempty"`
	// Target users for the message, identified by their session.
	Session []uint32 `protobuf:"varint,2,rep,name=session" json:"session,omitempty"`
	// The channels to which the message is sent, identified by their
	// channel_ids.
	ChannelId []uint32 `protobuf:"varint,3,rep,name=channel_id,json=channelId" json:"channel_id,omitempty"`
	// The root channels when sending message recursively to several channels,
	// identified by their channel_ids.
	TreeId []uint32 `protobuf:"varint,4,rep,name=tree_id,json=treeId" json:"tree_id,omitempty"`
	// The UTF-8 encoded message. May be HTML if the server allows.
	Message          *string `protobuf:"bytes,5,req,name=message" json:"message,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *TextMessage) Reset()                    { *m = TextMessage{} }
func (m *TextMessage) String() string            { return proto.CompactTextString(m) }
func (*TextMessage) ProtoMessage()               {}
func (*TextMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *TextMessage) GetActor() uint32 {
	if m != nil && m.Actor != nil {
		return *m.Actor
	}
	return 0
}

func (m *TextMessage) GetSession() []uint32 {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *TextMessage) GetChannelId() []uint32 {
	if m != nil {
		return m.ChannelId
	}
	return nil
}

func (m *TextMessage) GetTreeId() []uint32 {
	if m != nil {
		return m.TreeId
	}
	return nil
}

func (m *TextMessage) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

type PermissionDenied struct {
	// The denied permission when type is Permission.
	Permission *uint32 `protobuf:"varint,1,opt,name=permission" json:"permission,omitempty"`
	// channel_id for the channel where the permission was denied when type is
	// Permission.
	ChannelId *uint32 `protobuf:"varint,2,opt,name=channel_id,json=channelId" json:"channel_id,omitempty"`
	// The user who was denied permissions, identified by session.
	Session *uint32 `protobuf:"varint,3,opt,name=session" json:"session,omitempty"`
	// Textual reason for the denial.
	Reason *string `protobuf:"bytes,4,opt,name=reason" json:"reason,omitempty"`
	// Type of the denial.
	Type *PermissionDenied_DenyType `protobuf:"varint,5,opt,name=type,enum=MumbleProto.PermissionDenied_DenyType" json:"type,omitempty"`
	// The name that is invalid when type is UserName.
	Name             *string `protobuf:"bytes,6,opt,name=name" json:"name,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *PermissionDenied) Reset()                    { *m = PermissionDenied{} }
func (m *PermissionDenied) String() string            { return proto.CompactTextString(m) }
func (*PermissionDenied) ProtoMessage()               {}
func (*PermissionDenied) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *PermissionDenied) GetPermission() uint32 {
	if m != nil && m.Permission != nil {
		return *m.Permission
	}
	return 0
}

func (m *PermissionDenied) GetChannelId() uint32 {
	if m != nil && m.ChannelId != nil {
		return *m.ChannelId
	}
	return 0
}

func (m *PermissionDenied) GetSession() uint32 {
	if m != nil && m.Session != nil {
		return *m.Session
	}
	return 0
}

func (m *PermissionDenied) GetReason() string {
	if m != nil && m.Reason != nil {
		return *m.Reason
	}
	return ""
}

func (m *PermissionDenied) GetType() PermissionDenied_DenyType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return PermissionDenied_Text
}

func (m *PermissionDenied) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

type ACL struct {
	// Channel ID of the channel this message affects.
	ChannelId *uint32 `protobuf:"varint,1,req,name=channel_id,json=channelId" json:"channel_id,omitempty"`
	// True if the channel inherits its parent's ACLs.
	InheritAcls *bool `protobuf:"varint,2,opt,name=inherit_acls,json=inheritAcls,def=1" json:"inherit_acls,omitempty"`
	// User group specifications.
	Groups []*ACL_ChanGroup `protobuf:"bytes,3,rep,name=groups" json:"groups,omitempty"`
	// ACL specifications.
	Acls []*ACL_ChanACL `protobuf:"bytes,4,rep,name=acls" json:"acls,omitempty"`
	// True if the message is a query for ACLs instead of setting them.
	Query            *bool  `protobuf:"varint,5,opt,name=query,def=0" json:"query,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ACL) Reset()                    { *m = ACL{} }
func (m *ACL) String() string            { return proto.CompactTextString(m) }
func (*ACL) ProtoMessage()               {}
func (*ACL) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

const Default_ACL_InheritAcls bool = true
const Default_ACL_Query bool = false

func (m *ACL) GetChannelId() uint32 {
	if m != nil && m.ChannelId != nil {
		return *m.ChannelId
	}
	return 0
}

func (m *ACL) GetInheritAcls() bool {
	if m != nil && m.InheritAcls != nil {
		return *m.InheritAcls
	}
	return Default_ACL_InheritAcls
}

func (m *ACL) GetGroups() []*ACL_ChanGroup {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *ACL) GetAcls() []*ACL_ChanACL {
	if m != nil {
		return m.Acls
	}
	return nil
}

func (m *ACL) GetQuery() bool {
	if m != nil && m.Query != nil {
		return *m.Query
	}
	return Default_ACL_Query
}

type ACL_ChanGroup struct {
	// Name of the channel group, UTF-8 encoded.
	Name *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	// True if the group has been inherited from the parent (Read only).
	Inherited *bool `protobuf:"varint,2,opt,name=inherited,def=1" json:"inherited,omitempty"`
	// True if the group members are inherited.
	Inherit *bool `protobuf:"varint,3,opt,name=inherit,def=1" json:"inherit,omitempty"`
	// True if the group can be inherited by sub channels.
	Inheritable *bool `protobuf:"varint,4,opt,name=inheritable,def=1" json:"inheritable,omitempty"`
	// Users explicitly included in this group, identified by user_id.
	Add []uint32 `protobuf:"varint,5,rep,name=add" json:"add,omitempty"`
	// Users explicitly removed from this group in this channel if the group
	// has been inherited, identified by user_id.
	Remove []uint32 `protobuf:"varint,6,rep,name=remove" json:"remove,omitempty"`
	// Users inherited, identified by user_id.
	InheritedMembers []uint32 `protobuf:"varint,7,rep,name=inherited_members,json=inheritedMembers" json:"inherited_members,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ACL_ChanGroup) Reset()                    { *m = ACL_ChanGroup{} }
func (m *ACL_ChanGroup) String() string            { return proto.CompactTextString(m) }
func (*ACL_ChanGroup) ProtoMessage()               {}
func (*ACL_ChanGroup) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13, 0} }

const Default_ACL_ChanGroup_Inherited bool = true
const Default_ACL_ChanGroup_Inherit bool = true
const Default_ACL_ChanGroup_Inheritable bool = true

func (m *ACL_ChanGroup) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ACL_ChanGroup) GetInherited() bool {
	if m != nil && m.Inherited != nil {
		return *m.Inherited
	}
	return Default_ACL_ChanGroup_Inherited
}

func (m *ACL_ChanGroup) GetInherit() bool {
	if m != nil && m.Inherit != nil {
		return *m.Inherit
	}
	return Default_ACL_ChanGroup_Inherit
}

func (m *ACL_ChanGroup) GetInheritable() bool {
	if m != nil && m.Inheritable != nil {
		return *m.Inheritable
	}
	return Default_ACL_ChanGroup_Inheritable
}

func (m *ACL_ChanGroup) GetAdd() []uint32 {
	if m != nil {
		return m.Add
	}
	return nil
}

func (m *ACL_ChanGroup) GetRemove() []uint32 {
	if m != nil {
		return m.Remove
	}
	return nil
}

func (m *ACL_ChanGroup) GetInheritedMembers() []uint32 {
	if m != nil {
		return m.InheritedMembers
	}
	return nil
}

type ACL_ChanACL struct {
	// True if this ACL applies to the current channel.
	ApplyHere *bool `protobuf:"varint,1,opt,name=apply_here,json=applyHere,def=1" json:"apply_here,omitempty"`
	// True if this ACL applies to the sub channels.
	ApplySubs *bool `protobuf:"varint,2,opt,name=apply_subs,json=applySubs,def=1" json:"apply_subs,omitempty"`
	// True if the ACL has been inherited from the parent.
	Inherited *bool `protobuf:"varint,3,opt,name=inherited,def=1" json:"inherited,omitempty"`
	// ID of the user that is affected by this ACL.
	UserId *uint32 `protobuf:"varint,4,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	// ID of the group that is affected by this ACL.
	Group *string `protobuf:"bytes,5,opt,name=group" json:"group,omitempty"`
	// Bit flag field of the permissions granted by this ACL.
	Grant *uint32 `protobuf:"varint,6,opt,name=grant" json:"grant,omitempty"`
	// Bit flag field of the permissions denied by this ACL.
	Deny             *uint32 `protobuf:"varint,7,opt,name=deny" json:"deny,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ACL_ChanACL) Reset()                    { *m = ACL_ChanACL{} }
func (m *ACL_ChanACL) String() string            { return proto.CompactTextString(m) }
func (*ACL_ChanACL) ProtoMessage()               {}
func (*ACL_ChanACL) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13, 1} }

const Default_ACL_ChanACL_ApplyHere bool = true
const Default_ACL_ChanACL_ApplySubs bool = true
const Default_ACL_ChanACL_Inherited bool = true

func (m *ACL_ChanACL) GetApplyHere() bool {
	if m != nil && m.ApplyHere != nil {
		return *m.ApplyHere
	}
	return Default_ACL_ChanACL_ApplyHere
}

func (m *ACL_ChanACL) GetApplySubs() bool {
	if m != nil && m.ApplySubs != nil {
		return *m.ApplySubs
	}
	return Default_ACL_ChanACL_ApplySubs
}

func (m *ACL_ChanACL) GetInherited() bool {
	if m != nil && m.Inherited != nil {
		return *m.Inherited
	}
	return Default_ACL_ChanACL_Inherited
}

func (m *ACL_ChanACL) GetUserId() uint32 {
	if m != nil && m.UserId != nil {
		return *m.UserId
	}
	return 0
}

func (m *ACL_ChanACL) GetGroup() string {
	if m != nil && m.Group != nil {
		return *m.Group
	}
	return ""
}

func (m *ACL_ChanACL) GetGrant() uint32 {
	if m != nil && m.Grant != nil {
		return *m.Grant
	}
	return 0
}

func (m *ACL_ChanACL) GetDeny() uint32 {
	if m != nil && m.Deny != nil {
		return *m.Deny
	}
	return 0
}

// Client may use this message to refresh its registered user information. The
// client should fill the IDs or Names of the users it wants to refresh. The
// server fills the missing parts and sends the message back.
type QueryUsers struct {
	// user_ids.
	Ids []uint32 `protobuf:"varint,1,rep,name=ids" json:"ids,omitempty"`
	// User names in the same order as ids.
	Names            []string `protobuf:"bytes,2,rep,name=names" json:"names,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *QueryUsers) Reset()                    { *m = QueryUsers{} }
func (m *QueryUsers) String() string            { return proto.CompactTextString(m) }
func (*QueryUsers) ProtoMessage()               {}
func (*QueryUsers) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *QueryUsers) GetIds() []uint32 {
	if m != nil {
		return m.Ids
	}
	return nil
}

func (m *QueryUsers) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

// Used to initialize and resync the UDP encryption. Either side may request a
// resync by sending the message without any values filled. The resync is
// performed by sending the message with only the client or server nonce
// filled.
type CryptSetup struct {
	// Encryption key.
	Key []byte `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	// Client nonce.
	ClientNonce []byte `protobuf:"bytes,2,opt,name=client_nonce,json=clientNonce" json:"client_nonce,omitempty"`
	// Server nonce.
	ServerNonce      []byte `protobuf:"bytes,3,opt,name=server_nonce,json=serverNonce" json:"server_nonce,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *CryptSetup) Reset()                    { *m = CryptSetup{} }
func (m *CryptSetup) String() string            { return proto.CompactTextString(m) }
func (*CryptSetup) ProtoMessage()               {}
func (*CryptSetup) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *CryptSetup) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *CryptSetup) GetClientNonce() []byte {
	if m != nil {
		return m.ClientNonce
	}
	return nil
}

func (m *CryptSetup) GetServerNonce() []byte {
	if m != nil {
		return m.ServerNonce
	}
	return nil
}

type ContextActionModify struct {
	// The action name.
	Action *string `protobuf:"bytes,1,req,name=action" json:"action,omitempty"`
	// The display name of the action.
	Text *string `protobuf:"bytes,2,opt,name=text" json:"text,omitempty"`
	// Context bit flags defining where the action should be displayed.
	Context          *uint32                        `protobuf:"varint,3,opt,name=context" json:"context,omitempty"`
	Operation        *ContextActionModify_Operation `protobuf:"varint,4,opt,name=operation,enum=MumbleProto.ContextActionModify_Operation" json:"operation,omitempty"`
	XXX_unrecognized []byte                         `json:"-"`
}

func (m *ContextActionModify) Reset()                    { *m = ContextActionModify{} }
func (m *ContextActionModify) String() string            { return proto.CompactTextString(m) }
func (*ContextActionModify) ProtoMessage()               {}
func (*ContextActionModify) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *ContextActionModify) GetAction() string {
	if m != nil && m.Action != nil {
		return *m.Action
	}
	return ""
}

func (m *ContextActionModify) GetText() string {
	if m != nil && m.Text != nil {
		return *m.Text
	}
	return ""
}

func (m *ContextActionModify) GetContext() uint32 {
	if m != nil && m.Context != nil {
		return *m.Context
	}
	return 0
}

func (m *ContextActionModify) GetOperation() ContextActionModify_Operation {
	if m != nil && m.Operation != nil {
		return *m.Operation
	}
	return ContextActionModify_Add
}

// Sent by the client when it wants to initiate a Context action.
type ContextAction struct {
	// The target User for the action, identified by session.
	Session *uint32 `protobuf:"varint,1,opt,name=session" json:"session,omitempty"`
	// The target Channel for the action, identified by channel_id.
	ChannelId *uint32 `protobuf:"varint,2,opt,name=channel_id,json=channelId" json:"channel_id,omitempty"`
	// The action that should be executed.
	Action           *string `protobuf:"bytes,3,req,name=action" json:"action,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ContextAction) Reset()                    { *m = ContextAction{} }
func (m *ContextAction) String() string            { return proto.CompactTextString(m) }
func (*ContextAction) ProtoMessage()               {}
func (*ContextAction) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *ContextAction) GetSession() uint32 {
	if m != nil && m.Session != nil {
		return *m.Session
	}
	return 0
}

func (m *ContextAction) GetChannelId() uint32 {
	if m != nil && m.ChannelId != nil {
		return *m.ChannelId
	}
	return 0
}

func (m *ContextAction) GetAction() string {
	if m != nil && m.Action != nil {
		return *m.Action
	}
	return ""
}

// Lists the registered users.
type UserList struct {
	// A list of registered users.
	Users            []*UserList_User `protobuf:"bytes,1,rep,name=users" json:"users,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *UserList) Reset()                    { *m = UserList{} }
func (m *UserList) String() string            { return proto.CompactTextString(m) }
func (*UserList) ProtoMessage()               {}
func (*UserList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *UserList) GetUsers() []*UserList_User {
	if m != nil {
		return m.Users
	}
	return nil
}

type UserList_User struct {
	// Registered user ID.
	UserId *uint32 `protobuf:"varint,1,req,name=user_id,json=userId" json:"user_id,omitempty"`
	// Registered user name.
	Name             *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	LastSeen         *string `protobuf:"bytes,3,opt,name=last_seen,json=lastSeen" json:"last_seen,omitempty"`
	LastChannel      *uint32 `protobuf:"varint,4,opt,name=last_channel,json=lastChannel" json:"last_channel,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *UserList_User) Reset()                    { *m = UserList_User{} }
func (m *UserList_User) String() string            { return proto.CompactTextString(m) }
func (*UserList_User) ProtoMessage()               {}
func (*UserList_User) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18, 0} }

func (m *UserList_User) GetUserId() uint32 {
	if m != nil && m.UserId != nil {
		return *m.UserId
	}
	return 0
}

func (m *UserList_User) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *UserList_User) GetLastSeen() string {
	if m != nil && m.LastSeen != nil {
		return *m.LastSeen
	}
	return ""
}

func (m *UserList_User) GetLastChannel() uint32 {
	if m != nil && m.LastChannel != nil {
		return *m.LastChannel
	}
	return 0
}

// Sent by the client when it wants to register or clear whisper targets.
//
// Note: The first available target ID is 1 as 0 is reserved for normal
// talking. Maximum target ID is 30.
type VoiceTarget struct {
	// Voice target ID.
	Id *uint32 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// The receivers that this voice target includes.
	Targets          []*VoiceTarget_Target `protobuf:"bytes,2,rep,name=targets" json:"targets,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *VoiceTarget) Reset()                    { *m = VoiceTarget{} }
func (m *VoiceTarget) String() string            { return proto.CompactTextString(m) }
func (*VoiceTarget) ProtoMessage()               {}
func (*VoiceTarget) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *VoiceTarget) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *VoiceTarget) GetTargets() []*VoiceTarget_Target {
	if m != nil {
		return m.Targets
	}
	return nil
}

type VoiceTarget_Target struct {
	// Users that are included as targets.
	Session []uint32 `protobuf:"varint,1,rep,name=session" json:"session,omitempty"`
	// Channel that is included as a target.
	ChannelId *uint32 `protobuf:"varint,2,opt,name=channel_id,json=channelId" json:"channel_id,omitempty"`
	// ACL group that is included as a target.
	Group *string `protobuf:"bytes,3,opt,name=group" json:"group,omitempty"`
	// True if the voice should follow links from the specified channel.
	Links *bool `protobuf:"varint,4,opt,name=links,def=0" json:"links,omitempty"`
	// True if the voice should also be sent to children of the specific
	// channel.
	Children         *bool  `protobuf:"varint,5,opt,name=children,def=0" json:"children,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *VoiceTarget_Target) Reset()                    { *m = VoiceTarget_Target{} }
func (m *VoiceTarget_Target) String() string            { return proto.CompactTextString(m) }
func (*VoiceTarget_Target) ProtoMessage()               {}
func (*VoiceTarget_Target) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19, 0} }

const Default_VoiceTarget_Target_Links bool = false
const Default_VoiceTarget_Target_Children bool = false

func (m *VoiceTarget_Target) GetSession() []uint32 {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *VoiceTarget_Target) GetChannelId() uint32 {
	if m != nil && m.ChannelId != nil {
		return *m.ChannelId
	}
	return 0
}

func (m *VoiceTarget_Target) GetGroup() string {
	if m != nil && m.Group != nil {
		return *m.Group
	}
	return ""
}

func (m *VoiceTarget_Target) GetLinks() bool {
	if m != nil && m.Links != nil {
		return *m.Links
	}
	return Default_VoiceTarget_Target_Links
}

func (m *VoiceTarget_Target) GetChildren() bool {
	if m != nil && m.Children != nil {
		return *m.Children
	}
	return Default_VoiceTarget_Target_Children
}

// Sent by the client when it wants permissions for a certain channel. Sent by
// the server when it replies to the query or wants the user to resync all
// channel permissions.
type PermissionQuery struct {
	// channel_id of the channel for which the permissions are queried.
	ChannelId *uint32 `protobuf:"varint,1,opt,name=channel_id,json=channelId" json:"channel_id,omitempty"`
	// Channel permissions.
	Permissions *uint32 `protobuf:"varint,2,opt,name=permissions" json:"permissions,omitempty"`
	// True if the client should drop its current permission information for all
	// channels.
	Flush            *bool  `protobuf:"varint,3,opt,name=flush,def=0" json:"flush,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *PermissionQuery) Reset()                    { *m = PermissionQuery{} }
func (m *PermissionQuery) String() string            { return proto.CompactTextString(m) }
func (*PermissionQuery) ProtoMessage()               {}
func (*PermissionQuery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

const Default_PermissionQuery_Flush bool = false

func (m *PermissionQuery) GetChannelId() uint32 {
	if m != nil && m.ChannelId != nil {
		return *m.ChannelId
	}
	return 0
}

func (m *PermissionQuery) GetPermissions() uint32 {
	if m != nil && m.Permissions != nil {
		return *m.Permissions
	}
	return 0
}

func (m *PermissionQuery) GetFlush() bool {
	if m != nil && m.Flush != nil {
		return *m.Flush
	}
	return Default_PermissionQuery_Flush
}

// Sent by the server to notify the users of the version of the CELT codec they
// should use. This may change during the connection when new users join.
type CodecVersion struct {
	// The version of the CELT Alpha codec.
	Alpha *int32 `protobuf:"varint,1,req,name=alpha" json:"alpha,omitempty"`
	// The version of the CELT Beta codec.
	Beta *int32 `protobuf:"varint,2,req,name=beta" json:"beta,omitempty"`
	// True if the user should prefer Alpha over Beta.
	PreferAlpha      *bool  `protobuf:"varint,3,req,name=prefer_alpha,json=preferAlpha,def=1" json:"prefer_alpha,omitempty"`
	Opus             *bool  `protobuf:"varint,4,opt,name=opus,def=0" json:"opus,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *CodecVersion) Reset()                    { *m = CodecVersion{} }
func (m *CodecVersion) String() string            { return proto.CompactTextString(m) }
func (*CodecVersion) ProtoMessage()               {}
func (*CodecVersion) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

const Default_CodecVersion_PreferAlpha bool = true
const Default_CodecVersion_Opus bool = false

func (m *CodecVersion) GetAlpha() int32 {
	if m != nil && m.Alpha != nil {
		return *m.Alpha
	}
	return 0
}

func (m *CodecVersion) GetBeta() int32 {
	if m != nil && m.Beta != nil {
		return *m.Beta
	}
	return 0
}

func (m *CodecVersion) GetPreferAlpha() bool {
	if m != nil && m.PreferAlpha != nil {
		return *m.PreferAlpha
	}
	return Default_CodecVersion_PreferAlpha
}

func (m *CodecVersion) GetOpus() bool {
	if m != nil && m.Opus != nil {
		return *m.Opus
	}
	return Default_CodecVersion_Opus
}

// Used to communicate user stats between the server and clients.
type UserStats struct {
	// User whose stats these are.
	Session *uint32 `protobuf:"varint,1,opt,name=session" json:"session,omitempty"`
	// True if the message contains only mutable stats (packets, ping).
	StatsOnly *bool `protobuf:"varint,2,opt,name=stats_only,json=statsOnly,def=0" json:"stats_only,omitempty"`
	// Full user certificate chain of the user certificate in DER format.
	Certificates [][]byte `protobuf:"bytes,3,rep,name=certificates" json:"certificates,omitempty"`
	// Packet statistics for packets received from the client.
	FromClient *UserStats_Stats `protobuf:"bytes,4,opt,name=from_client,json=fromClient" json:"from_client,omitempty"`
	// Packet statistics for packets sent by the server.
	FromServer *UserStats_Stats `protobuf:"bytes,5,opt,name=from_server,json=fromServer" json:"from_server,omitempty"`
	// Amount of UDP packets sent.
	UdpPackets *uint32 `protobuf:"varint,6,opt,name=udp_packets,json=udpPackets" json:"udp_packets,omitempty"`
	// Amount of TCP packets sent.
	TcpPackets *uint32 `protobuf:"varint,7,opt,name=tcp_packets,json=tcpPackets" json:"tcp_packets,omitempty"`
	// UDP ping average.
	UdpPingAvg *float32 `protobuf:"fixed32,8,opt,name=udp_ping_avg,json=udpPingAvg" json:"udp_ping_avg,omitempty"`
	// UDP ping variance.
	UdpPingVar *float32 `protobuf:"fixed32,9,opt,name=udp_ping_var,json=udpPingVar" json:"udp_ping_var,omitempty"`
	// TCP ping average.
	TcpPingAvg *float32 `protobuf:"fixed32,10,opt,name=tcp_ping_avg,json=tcpPingAvg" json:"tcp_ping_avg,omitempty"`
	// TCP ping variance.
	TcpPingVar *float32 `protobuf:"fixed32,11,opt,name=tcp_ping_var,json=tcpPingVar" json:"tcp_ping_var,omitempty"`
	// Client version.
	Version *Version `protobuf:"bytes,12,opt,name=version" json:"version,omitempty"`
	// A list of CELT bitstream version constants supported by the client of this
	// user.
	CeltVersions []int32 `protobuf:"varint,13,rep,name=celt_versions,json=celtVersions" json:"celt_versions,omitempty"`
	// Client IP address.
	Address []byte `protobuf:"bytes,14,opt,name=address" json:"address,omitempty"`
	// Bandwith used by this client.
	Bandwidth *uint32 `protobuf:"varint,15,opt,name=bandwidth" json:"bandwidth,omitempty"`
	// Connection duration.
	Onlinesecs *uint32 `protobuf:"varint,16,opt,name=onlinesecs" json:"onlinesecs,omitempty"`
	// Duration since last activity.
	Idlesecs *uint32 `protobuf:"varint,17,opt,name=idlesecs" json:"idlesecs,omitempty"`
	// True if the user has a strong certificate.
	StrongCertificate *bool  `protobuf:"varint,18,opt,name=strong_certificate,json=strongCertificate,def=0" json:"strong_certificate,omitempty"`
	Opus              *bool  `protobuf:"varint,19,opt,name=opus,def=0" json:"opus,omitempty"`
	XXX_unrecognized  []byte `json:"-"`
}

func (m *UserStats) Reset()                    { *m = UserStats{} }
func (m *UserStats) String() string            { return proto.CompactTextString(m) }
func (*UserStats) ProtoMessage()               {}
func (*UserStats) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

const Default_UserStats_StatsOnly bool = false
const Default_UserStats_StrongCertificate bool = false
const Default_UserStats_Opus bool = false

func (m *UserStats) GetSession() uint32 {
	if m != nil && m.Session != nil {
		return *m.Session
	}
	return 0
}

func (m *UserStats) GetStatsOnly() bool {
	if m != nil && m.StatsOnly != nil {
		return *m.StatsOnly
	}
	return Default_UserStats_StatsOnly
}

func (m *UserStats) GetCertificates() [][]byte {
	if m != nil {
		return m.Certificates
	}
	return nil
}

func (m *UserStats) GetFromClient() *UserStats_Stats {
	if m != nil {
		return m.FromClient
	}
	return nil
}

func (m *UserStats) GetFromServer() *UserStats_Stats {
	if m != nil {
		return m.FromServer
	}
	return nil
}

func (m *UserStats) GetUdpPackets() uint32 {
	if m != nil && m.UdpPackets != nil {
		return *m.UdpPackets
	}
	return 0
}

func (m *UserStats) GetTcpPackets() uint32 {
	if m != nil && m.TcpPackets != nil {
		return *m.TcpPackets
	}
	return 0
}

func (m *UserStats) GetUdpPingAvg() float32 {
	if m != nil && m.UdpPingAvg != nil {
		return *m.UdpPingAvg
	}
	return 0
}

func (m *UserStats) GetUdpPingVar() float32 {
	if m != nil && m.UdpPingVar != nil {
		return *m.UdpPingVar
	}
	return 0
}

func (m *UserStats) GetTcpPingAvg() float32 {
	if m != nil && m.TcpPingAvg != nil {
		return *m.TcpPingAvg
	}
	return 0
}

func (m *UserStats) GetTcpPingVar() float32 {
	if m != nil && m.TcpPingVar != nil {
		return *m.TcpPingVar
	}
	return 0
}

func (m *UserStats) GetVersion() *Version {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *UserStats) GetCeltVersions() []int32 {
	if m != nil {
		return m.CeltVersions
	}
	return nil
}

func (m *UserStats) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *UserStats) GetBandwidth() uint32 {
	if m != nil && m.Bandwidth != nil {
		return *m.Bandwidth
	}
	return 0
}

func (m *UserStats) GetOnlinesecs() uint32 {
	if m != nil && m.Onlinesecs != nil {
		return *m.Onlinesecs
	}
	return 0
}

func (m *UserStats) GetIdlesecs() uint32 {
	if m != nil && m.Idlesecs != nil {
		return *m.Idlesecs
	}
	return 0
}

func (m *UserStats) GetStrongCertificate() bool {
	if m != nil && m.StrongCertificate != nil {
		return *m.StrongCertificate
	}
	return Default_UserStats_StrongCertificate
}

func (m *UserStats) GetOpus() bool {
	if m != nil && m.Opus != nil {
		return *m.Opus
	}
	return Default_UserStats_Opus
}

type UserStats_Stats struct {
	// The amount of good packets received.
	Good *uint32 `protobuf:"varint,1,opt,name=good" json:"good,omitempty"`
	// The amount of late packets received.
	Late *uint32 `protobuf:"varint,2,opt,name=late" json:"late,omitempty"`
	// The amount of packets never received.
	Lost *uint32 `protobuf:"varint,3,opt,name=lost" json:"lost,omitempty"`
	// The amount of nonce resyncs.
	Resync           *uint32 `protobuf:"varint,4,opt,name=resync" json:"resync,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *UserStats_Stats) Reset()                    { *m = UserStats_Stats{} }
func (m *UserStats_Stats) String() string            { return proto.CompactTextString(m) }
func (*UserStats_Stats) ProtoMessage()               {}
func (*UserStats_Stats) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22, 0} }

func (m *UserStats_Stats) GetGood() uint32 {
	if m != nil && m.Good != nil {
		return *m.Good
	}
	return 0
}

func (m *UserStats_Stats) GetLate() uint32 {
	if m != nil && m.Late != nil {
		return *m.Late
	}
	return 0
}

func (m *UserStats_Stats) GetLost() uint32 {
	if m != nil && m.Lost != nil {
		return *m.Lost
	}
	return 0
}

func (m *UserStats_Stats) GetResync() uint32 {
	if m != nil && m.Resync != nil {
		return *m.Resync
	}
	return 0
}

// Used by the client to request binary data from the server. By default large
// comments or textures are not sent within standard messages but instead the
// hash is. If the client does not recognize the hash it may request the
// resource when it needs it. The client does so by sending a RequestBlob
// message with the correct fields filled with the user sessions or channel_ids
// it wants to receive. The server replies to this by sending a new
// UserState/ChannelState message with the resources filled even if they would
// normally be transmitted as hashes.
type RequestBlob struct {
	// sessions of the requested UserState textures.
	SessionTexture []uint32 `protobuf:"varint,1,rep,name=session_texture,json=sessionTexture" json:"session_texture,omitempty"`
	// sessions of the requested UserState comments.
	SessionComment []uint32 `protobuf:"varint,2,rep,name=session_comment,json=sessionComment" json:"session_comment,omitempty"`
	// channel_ids of the requested ChannelState descriptions.
	ChannelDescription []uint32 `protobuf:"varint,3,rep,name=channel_description,json=channelDescription" json:"channel_description,omitempty"`
	XXX_unrecognized   []byte   `json:"-"`
}

func (m *RequestBlob) Reset()                    { *m = RequestBlob{} }
func (m *RequestBlob) String() string            { return proto.CompactTextString(m) }
func (*RequestBlob) ProtoMessage()               {}
func (*RequestBlob) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *RequestBlob) GetSessionTexture() []uint32 {
	if m != nil {
		return m.SessionTexture
	}
	return nil
}

func (m *RequestBlob) GetSessionComment() []uint32 {
	if m != nil {
		return m.SessionComment
	}
	return nil
}

func (m *RequestBlob) GetChannelDescription() []uint32 {
	if m != nil {
		return m.ChannelDescription
	}
	return nil
}

// Sent by the server when it informs the clients on server configuration
// details.
type ServerConfig struct {
	// The maximum bandwidth the clients should use.
	MaxBandwidth *uint32 `protobuf:"varint,1,opt,name=max_bandwidth,json=maxBandwidth" json:"max_bandwidth,omitempty"`
	// Server welcome text.
	WelcomeText *string `protobuf:"bytes,2,opt,name=welcome_text,json=welcomeText" json:"welcome_text,omitempty"`
	// True if the server allows HTML.
	AllowHtml *bool `protobuf:"varint,3,opt,name=allow_html,json=allowHtml" json:"allow_html,omitempty"`
	// Maximum text message length.
	MessageLength *uint32 `protobuf:"varint,4,opt,name=message_length,json=messageLength" json:"message_length,omitempty"`
	// Maximum image message length.
	ImageMessageLength *uint32 `protobuf:"varint,5,opt,name=image_message_length,json=imageMessageLength" json:"image_message_length,omitempty"`
	// The maximum number of users allowed on the server.
	MaxUsers         *uint32 `protobuf:"varint,6,opt,name=max_users,json=maxUsers" json:"max_users,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ServerConfig) Reset()                    { *m = ServerConfig{} }
func (m *ServerConfig) String() string            { return proto.CompactTextString(m) }
func (*ServerConfig) ProtoMessage()               {}
func (*ServerConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *ServerConfig) GetMaxBandwidth() uint32 {
	if m != nil && m.MaxBandwidth != nil {
		return *m.MaxBandwidth
	}
	return 0
}

func (m *ServerConfig) GetWelcomeText() string {
	if m != nil && m.WelcomeText != nil {
		return *m.WelcomeText
	}
	return ""
}

func (m *ServerConfig) GetAllowHtml() bool {
	if m != nil && m.AllowHtml != nil {
		return *m.AllowHtml
	}
	return false
}

func (m *ServerConfig) GetMessageLength() uint32 {
	if m != nil && m.MessageLength != nil {
		return *m.MessageLength
	}
	return 0
}

func (m *ServerConfig) GetImageMessageLength() uint32 {
	if m != nil && m.ImageMessageLength != nil {
		return *m.ImageMessageLength
	}
	return 0
}

func (m *ServerConfig) GetMaxUsers() uint32 {
	if m != nil && m.MaxUsers != nil {
		return *m.MaxUsers
	}
	return 0
}

// Sent by the server to inform the clients of suggested client configuration
// specified by the server administrator.
type SuggestConfig struct {
	// Suggested client version.
	Version *uint32 `protobuf:"varint,1,opt,name=version" json:"version,omitempty"`
	// True if the administrator suggests positional audio to be used on this
	// server.
	Positional *bool `protobuf:"varint,2,opt,name=positional" json:"positional,omitempty"`
	// True if the administrator suggests push to talk to be used on this server.
	PushToTalk       *bool  `protobuf:"varint,3,opt,name=push_to_talk,json=pushToTalk" json:"push_to_talk,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *SuggestConfig) Reset()                    { *m = SuggestConfig{} }
func (m *SuggestConfig) String() string            { return proto.CompactTextString(m) }
func (*SuggestConfig) ProtoMessage()               {}
func (*SuggestConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *SuggestConfig) GetVersion() uint32 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

func (m *SuggestConfig) GetPositional() bool {
	if m != nil && m.Positional != nil {
		return *m.Positional
	}
	return false
}

func (m *SuggestConfig) GetPushToTalk() bool {
	if m != nil && m.PushToTalk != nil {
		return *m.PushToTalk
	}
	return false
}

func init() {
	proto.RegisterType((*Version)(nil), "MumbleProto.Version")
	proto.RegisterType((*UDPTunnel)(nil), "MumbleProto.UDPTunnel")
	proto.RegisterType((*Authenticate)(nil), "MumbleProto.Authenticate")
	proto.RegisterType((*Ping)(nil), "MumbleProto.Ping")
	proto.RegisterType((*Reject)(nil), "MumbleProto.Reject")
	proto.RegisterType((*ServerSync)(nil), "MumbleProto.ServerSync")
	proto.RegisterType((*ChannelRemove)(nil), "MumbleProto.ChannelRemove")
	proto.RegisterType((*ChannelState)(nil), "MumbleProto.ChannelState")
	proto.RegisterType((*UserRemove)(nil), "MumbleProto.UserRemove")
	proto.RegisterType((*UserState)(nil), "MumbleProto.UserState")
	proto.RegisterType((*BanList)(nil), "MumbleProto.BanList")
	proto.RegisterType((*BanList_BanEntry)(nil), "MumbleProto.BanList.BanEntry")
	proto.RegisterType((*TextMessage)(nil), "MumbleProto.TextMessage")
	proto.RegisterType((*PermissionDenied)(nil), "MumbleProto.PermissionDenied")
	proto.RegisterType((*ACL)(nil), "MumbleProto.ACL")
	proto.RegisterType((*ACL_ChanGroup)(nil), "MumbleProto.ACL.ChanGroup")
	proto.RegisterType((*ACL_ChanACL)(nil), "MumbleProto.ACL.ChanACL")
	proto.RegisterType((*QueryUsers)(nil), "MumbleProto.QueryUsers")
	proto.RegisterType((*CryptSetup)(nil), "MumbleProto.CryptSetup")
	proto.RegisterType((*ContextActionModify)(nil), "MumbleProto.ContextActionModify")
	proto.RegisterType((*ContextAction)(nil), "MumbleProto.ContextAction")
	proto.RegisterType((*UserList)(nil), "MumbleProto.UserList")
	proto.RegisterType((*UserList_User)(nil), "MumbleProto.UserList.User")
	proto.RegisterType((*VoiceTarget)(nil), "MumbleProto.VoiceTarget")
	proto.RegisterType((*VoiceTarget_Target)(nil), "MumbleProto.VoiceTarget.Target")
	proto.RegisterType((*PermissionQuery)(nil), "MumbleProto.PermissionQuery")
	proto.RegisterType((*CodecVersion)(nil), "MumbleProto.CodecVersion")
	proto.RegisterType((*UserStats)(nil), "MumbleProto.UserStats")
	proto.RegisterType((*UserStats_Stats)(nil), "MumbleProto.UserStats.Stats")
	proto.RegisterType((*RequestBlob)(nil), "MumbleProto.RequestBlob")
	proto.RegisterType((*ServerConfig)(nil), "MumbleProto.ServerConfig")
	proto.RegisterType((*SuggestConfig)(nil), "MumbleProto.SuggestConfig")
	proto.RegisterEnum("MumbleProto.Reject_RejectType", Reject_RejectType_name, Reject_RejectType_value)
	proto.RegisterEnum("MumbleProto.PermissionDenied_DenyType", PermissionDenied_DenyType_name, PermissionDenied_DenyType_value)
	proto.RegisterEnum("MumbleProto.ContextActionModify_Context", ContextActionModify_Context_name, ContextActionModify_Context_value)
	proto.RegisterEnum("MumbleProto.ContextActionModify_Operation", ContextActionModify_Operation_name, ContextActionModify_Operation_value)
}

func init() { proto.RegisterFile("Mumble.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 2445 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xdc, 0x58, 0xcd, 0x72, 0x2c, 0x37,
	0x15, 0x4e, 0xcf, 0xff, 0x9c, 0x99, 0xb1, 0xdb, 0xba, 0x26, 0x19, 0x9c, 0xdc, 0xc4, 0xe9, 0x0b,
	0x89, 0x03, 0x29, 0x13, 0x5c, 0xd9, 0x24, 0x55, 0x2c, 0x7c, 0x7d, 0x09, 0x76, 0x61, 0xdf, 0x98,
	0xb6, 0x73, 0xb3, 0x60, 0xd1, 0xc8, 0xd3, 0xf2, 0x4c, 0xe3, 0x9e, 0x56, 0xa7, 0xa5, 0xf6, 0xbd,
	0x53, 0xc5, 0x12, 0xd8, 0x92, 0x2a, 0x16, 0xec, 0x78, 0x00, 0x8a, 0x4a, 0x15, 0x0f, 0xc0, 0x86,
	0x27, 0xe0, 0x05, 0xd8, 0xb0, 0x65, 0x47, 0x15, 0x7b, 0xea, 0x1c, 0xa9, 0xff, 0xec, 0xc9, 0x0f,
	0x5b, 0x36, 0x33, 0x3a, 0x9f, 0x3e, 0x49, 0xa7, 0x8f, 0xce, 0x8f, 0x24, 0x18, 0x9f, 0xe5, 0xcb,
	0xab, 0x58, 0xec, 0xa7, 0x99, 0xd4, 0x92, 0x8d, 0x8c, 0x74, 0x8e, 0x82, 0x17, 0x43, 0xff, 0x99,
	0xc8, 0x54, 0x24, 0x13, 0x36, 0x85, 0xfe, 0xad, 0x69, 0x4e, 0x9d, 0x5d, 0x67, 0x6f, 0xe2, 0x17,
	0x22, 0xf6, 0x64, 0x22, 0x16, 0x5c, 0x89, 0x69, 0x6b, 0xd7, 0xd9, 0x1b, 0xfa, 0x85, 0xc8, 0x36,
	0xa0, 0x25, 0xd5, 0xb4, 0x4d, 0x60, 0x4b, 0x2a, 0xf6, 0x10, 0x40, 0xaa, 0xa0, 0x98, 0xa6, 0x43,
	0xf8, 0x50, 0x2a, 0xbb, 0x84, 0xf7, 0x08, 0x86, 0x9f, 0x3c, 0x39, 0xbf, 0xcc, 0x93, 0x44, 0xc4,
	0xec, 0x65, 0xe8, 0xa5, 0x7c, 0x76, 0x23, 0xf4, 0xd4, 0xd9, 0x6d, 0xed, 0x8d, 0x7d, 0x2b, 0x79,
	0x7f, 0x74, 0x60, 0x7c, 0x98, 0xeb, 0x85, 0x48, 0x74, 0x34, 0xe3, 0x5a, 0xb0, 0x1d, 0x18, 0xe4,
	0x4a, 0x64, 0x09, 0x5f, 0x0a, 0xd2, 0x6c, 0xe8, 0x97, 0x32, 0xf6, 0xa5, 0x5c, 0xa9, 0xe7, 0x32,
	0x0b, 0xad, 0x6e, 0xa5, 0x8c, 0x0b, 0x68, 0x79, 0x23, 0x12, 0x54, 0xb0, 0xbd, 0x37, 0xf4, 0xad,
	0xc4, 0x1e, 0xc1, 0x64, 0x26, 0x62, 0x5d, 0xa8, 0xa9, 0xa6, 0x9d, 0xdd, 0xf6, 0x5e, 0xd7, 0x1f,
	0x23, 0x68, 0x35, 0x55, 0xec, 0xdb, 0xd0, 0x91, 0x69, 0xae, 0xa6, 0xdd, 0x5d, 0x67, 0x6f, 0xf0,
	0x61, 0xf7, 0x9a, 0xc7, 0x4a, 0xf8, 0x04, 0x79, 0x7f, 0x6b, 0x41, 0xe7, 0x3c, 0x4a, 0xe6, 0xec,
	0x35, 0x18, 0xea, 0x68, 0x29, 0x94, 0xe6, 0xcb, 0x94, 0x34, 0xeb, 0xf8, 0x15, 0xc0, 0x18, 0x74,
	0xe6, 0x52, 0x1a, 0xb5, 0x26, 0x3e, 0xb5, 0x11, 0x8b, 0xb9, 0x16, 0x64, 0xb1, 0x89, 0x4f, 0x6d,
	0xc2, 0xa4, 0xd2, 0x64, 0x2d, 0xc4, 0xa4, 0xd2, 0xa8, 0x7a, 0x26, 0xd4, 0x2a, 0x99, 0xd1, 0xfa,
	0x13, 0xdf, 0x4a, 0xec, 0x0d, 0x18, 0xe5, 0x61, 0x1a, 0x18, 0x4b, 0xa9, 0x69, 0x8f, 0x3a, 0x21,
	0x0f, 0xd3, 0x73, 0x83, 0x20, 0x41, 0xcf, 0x2a, 0x42, 0xdf, 0x10, 0xf4, 0xac, 0x24, 0xec, 0xc2,
	0x98, 0x66, 0x88, 0x92, 0x79, 0xc0, 0x6f, 0xe7, 0xd3, 0xc1, 0xae, 0xb3, 0xd7, 0x32, 0x53, 0x44,
	0xc9, 0xfc, 0xf0, 0x76, 0xde, 0x60, 0xdc, 0xf2, 0x6c, 0x3a, 0x6c, 0x30, 0x9e, 0xf1, 0x0c, 0x19,
	0xb4, 0x48, 0x31, 0x07, 0x18, 0x06, 0xae, 0x52, 0xcd, 0x51, 0x32, 0x70, 0x8e, 0x51, 0x83, 0xf1,
	0x8c, 0x67, 0xde, 0x6f, 0x5a, 0xd0, 0xf3, 0xc5, 0x2f, 0xc5, 0x4c, 0xb3, 0x03, 0xe8, 0xe8, 0x55,
	0x6a, 0xf6, 0x76, 0xe3, 0xe0, 0xf5, 0xfd, 0x9a, 0x7f, 0xee, 0x1b, 0x8a, 0xfd, 0xbb, 0x5c, 0xa5,
	0xc2, 0x27, 0xae, 0x31, 0x10, 0x57, 0x32, 0xb1, 0xbb, 0x6e, 0x25, 0xef, 0x0b, 0x07, 0xa0, 0x22,
	0xb3, 0x01, 0x74, 0x9e, 0xca, 0x44, 0xb8, 0x2f, 0x31, 0x17, 0xc6, 0x9f, 0x66, 0x32, 0x99, 0xdb,
	0x0d, 0x76, 0x1d, 0xf6, 0x00, 0x36, 0x4f, 0x92, 0x5b, 0x1e, 0x47, 0xe1, 0x27, 0xd6, 0x9b, 0xdc,
	0x16, 0xdb, 0x84, 0x11, 0xd1, 0x10, 0x3a, 0xff, 0xd4, 0x6d, 0xb3, 0x2d, 0x98, 0x10, 0x70, 0x21,
	0xb2, 0x5b, 0x82, 0x3a, 0x08, 0x15, 0x23, 0x4e, 0x92, 0x4f, 0x94, 0x70, 0xbb, 0x6c, 0x03, 0xc0,
	0x10, 0x3e, 0xca, 0xe3, 0xd8, 0xed, 0x21, 0xe5, 0xa9, 0x3c, 0x12, 0x99, 0x8e, 0xae, 0xc9, 0x87,
	0xdd, 0x3e, 0xfb, 0x16, 0x6c, 0xd5, 0xbc, 0x5a, 0x66, 0x1f, 0xf1, 0x28, 0x76, 0x07, 0xde, 0xe7,
	0x4e, 0x31, 0xf4, 0x02, 0x37, 0x78, 0x0a, 0x7d, 0x25, 0x54, 0x3d, 0x08, 0xad, 0x88, 0x5e, 0xbb,
	0xe4, 0x2f, 0x82, 0x2b, 0x9e, 0x84, 0xcf, 0xa3, 0x50, 0x2f, 0xac, 0x5f, 0x8d, 0x97, 0xfc, 0xc5,
	0xe3, 0x02, 0x63, 0x6f, 0xc2, 0xf8, 0xb9, 0x88, 0x67, 0x72, 0x29, 0x02, 0x2d, 0x5e, 0x68, 0x1b,
	0x99, 0x23, 0x8b, 0x5d, 0x8a, 0x17, 0x9a, 0xed, 0xc2, 0x28, 0x15, 0xd9, 0x32, 0x52, 0x85, 0xef,
	0xa3, 0xdb, 0xd6, 0x21, 0x6f, 0x1f, 0x26, 0x47, 0x0b, 0x8e, 0x31, 0xea, 0x8b, 0xa5, 0xbc, 0x15,
	0x18, 0xd5, 0x33, 0x03, 0x04, 0x51, 0x48, 0xd1, 0x3a, 0xf1, 0x87, 0x16, 0x39, 0x09, 0xbd, 0x7f,
	0xb4, 0x60, 0x6c, 0x07, 0x5c, 0x68, 0xf4, 0xe8, 0xbb, 0x7c, 0xa7, 0xc1, 0x37, 0x81, 0x9f, 0x89,
	0x44, 0xdb, 0x4f, 0xb0, 0x12, 0x06, 0x02, 0xc5, 0xb8, 0x51, 0x9a, 0xda, 0x6c, 0x1b, 0xba, 0x71,
	0x94, 0xdc, 0x98, 0x18, 0x9d, 0xf8, 0x46, 0xc0, 0x6f, 0x08, 0x85, 0x9a, 0x65, 0x51, 0xaa, 0xd1,
	0x52, 0x5d, 0xf3, 0x95, 0x35, 0x88, 0xbd, 0x0a, 0x43, 0xa2, 0x06, 0x3c, 0x0c, 0xa7, 0x3d, 0x1a,
	0x3b, 0x20, 0xe0, 0x30, 0x0c, 0xd1, 0x4a, 0xa6, 0x33, 0xa3, 0xef, 0x9b, 0xf6, 0xa9, 0x7f, 0x44,
	0x98, 0xfd, 0xe4, 0x47, 0x30, 0xd4, 0x62, 0x99, 0xca, 0x8c, 0x67, 0x2b, 0x8a, 0x91, 0x32, 0x07,
	0x54, 0x38, 0x7b, 0x08, 0x83, 0x54, 0xaa, 0x88, 0x74, 0xc0, 0x28, 0xe9, 0x7e, 0xe8, 0xbc, 0xe7,
	0x97, 0x10, 0x7b, 0x07, 0xdc, 0x9a, 0x4a, 0xc1, 0x82, 0xab, 0x05, 0x85, 0xca, 0xd8, 0xdf, 0xac,
	0xe1, 0xc7, 0x5c, 0x2d, 0x50, 0x5d, 0xdc, 0x5c, 0x4c, 0x6b, 0x8a, 0x82, 0x65, 0xe2, 0x0f, 0x96,
	0xfc, 0x05, 0xba, 0x99, 0xf2, 0xae, 0x01, 0xb0, 0x61, 0x35, 0x6b, 0x78, 0x48, 0xab, 0xee, 0x21,
	0xdb, 0xd0, 0xe5, 0x33, 0x2d, 0x33, 0x6b, 0x56, 0x23, 0xd4, 0x22, 0xa5, 0x5d, 0x8f, 0x14, 0xe6,
	0x42, 0xfb, 0x8a, 0x9b, 0x1c, 0x3d, 0xf0, 0xb1, 0xe9, 0xfd, 0xb9, 0x03, 0x43, 0x5c, 0xc8, 0x6c,
	0xe2, 0x97, 0x7b, 0xe2, 0xfa, 0x75, 0xd6, 0xed, 0xde, 0x2b, 0xd0, 0xc7, 0x4f, 0x42, 0x2f, 0x30,
	0xd9, 0xad, 0x87, 0xe2, 0x49, 0x78, 0xc7, 0x43, 0xba, 0x77, 0x3d, 0x84, 0x41, 0x67, 0x99, 0x6b,
	0x41, 0xf9, 0x6d, 0xe0, 0x53, 0x1b, 0xb1, 0x50, 0xf0, 0x6b, 0x4a, 0x69, 0x03, 0x9f, 0xda, 0x98,
	0xfd, 0x55, 0x9e, 0xa6, 0x99, 0x50, 0xca, 0x6c, 0x92, 0x5f, 0xca, 0x68, 0x52, 0x25, 0xe2, 0xeb,
	0x80, 0x26, 0x1a, 0xda, 0x4e, 0x11, 0x5f, 0x9f, 0xe1, 0x64, 0x45, 0x27, 0xcd, 0x08, 0x55, 0xe7,
	0x13, 0x9c, 0x75, 0x0a, 0x7d, 0x0c, 0x9e, 0x3c, 0x13, 0xb4, 0x15, 0x63, 0xbf, 0x10, 0xd9, 0x77,
	0x61, 0x23, 0x8d, 0xf3, 0x79, 0x94, 0x04, 0x33, 0x99, 0x50, 0x80, 0x8d, 0x89, 0x30, 0x31, 0xe8,
	0x91, 0x01, 0xd9, 0xdb, 0xb0, 0x69, 0x69, 0x51, 0x88, 0xf1, 0xae, 0x57, 0xd3, 0x09, 0x59, 0xc5,
	0x8e, 0x3e, 0xb1, 0x28, 0xae, 0x34, 0x93, 0xcb, 0x25, 0x86, 0xc2, 0x86, 0x29, 0xac, 0x56, 0xc4,
	0xaf, 0x25, 0x7f, 0xd9, 0x34, 0xd6, 0xc4, 0x36, 0xba, 0xad, 0xed, 0x36, 0xbe, 0xe4, 0xd2, 0xda,
	0x23, 0x8b, 0x1d, 0x5b, 0x8a, 0xd5, 0xd5, 0x50, 0xb6, 0x0c, 0xc5, 0x62, 0x44, 0x79, 0x07, 0xdc,
	0x34, 0x8b, 0x64, 0x16, 0xe9, 0x55, 0xa0, 0x52, 0xc1, 0x6f, 0x44, 0x36, 0x65, 0x64, 0x81, 0xcd,
	0x02, 0xbf, 0x30, 0x30, 0xd6, 0xb7, 0x4c, 0xcc, 0x64, 0x16, 0x46, 0xc9, 0x7c, 0xfa, 0x80, 0x38,
	0x15, 0xe0, 0xfd, 0xb6, 0x05, 0xfd, 0xc7, 0x3c, 0x39, 0x8d, 0x94, 0x66, 0x3f, 0x84, 0xce, 0x15,
	0x4f, 0xd4, 0xd4, 0xd9, 0x6d, 0xef, 0x8d, 0x0e, 0x1e, 0x36, 0x52, 0xb8, 0xe5, 0xe0, 0xff, 0x8f,
	0x13, 0x9d, 0xad, 0x7c, 0xa2, 0xb2, 0x57, 0xa1, 0xfb, 0x59, 0x2e, 0xb2, 0x15, 0x79, 0x51, 0x19,
	0x5d, 0x06, 0xdb, 0xf9, 0x93, 0x03, 0x83, 0x82, 0x8f, 0x56, 0xe2, 0x61, 0x48, 0x9b, 0x6c, 0x4e,
	0x0a, 0x85, 0x48, 0x7e, 0xc2, 0xd5, 0xcd, 0xb4, 0x45, 0x81, 0x40, 0xed, 0xb5, 0x7e, 0x58, 0x58,
	0xb3, 0x53, 0xb3, 0x66, 0x15, 0x17, 0xdd, 0x46, 0x5c, 0x6c, 0x43, 0x57, 0x69, 0x9e, 0x69, 0x72,
	0xbe, 0xa1, 0x6f, 0x04, 0xf4, 0xb4, 0x30, 0xcf, 0x38, 0x85, 0xba, 0x29, 0xaa, 0xa5, 0xec, 0xfd,
	0xce, 0x81, 0x11, 0xa6, 0xd6, 0x33, 0xa1, 0x14, 0x9f, 0x8b, 0x2a, 0x3e, 0x9c, 0x7a, 0x7c, 0xd4,
	0xe2, 0xa9, 0x45, 0xf9, 0xa6, 0x8c, 0xa7, 0x66, 0x30, 0xb4, 0xa9, 0xb3, 0x16, 0x0c, 0xaf, 0x40,
	0x5f, 0x67, 0x42, 0x98, 0x20, 0xc2, 0xbe, 0x1e, 0x8a, 0x27, 0x21, 0xce, 0xb8, 0x34, 0x4b, 0x4e,
	0xbb, 0xbb, 0x2d, 0xf4, 0x1e, 0x2b, 0x7a, 0xbf, 0x6f, 0x83, 0x7b, 0x5e, 0x66, 0xf4, 0x27, 0x22,
	0x89, 0x44, 0xc8, 0x5e, 0x07, 0xa8, 0xb2, 0xbc, 0xd5, 0xad, 0x86, 0xdc, 0x51, 0xa3, 0x75, 0x37,
	0x26, 0x6b, 0xfa, 0xb7, 0x9b, 0xf9, 0xa0, 0xb2, 0x64, 0xa7, 0x61, 0xc9, 0x0f, 0x6d, 0x5d, 0xef,
	0x52, 0x5d, 0x7f, 0xab, 0xe1, 0x14, 0x77, 0xb5, 0xdb, 0x7f, 0x22, 0x92, 0x55, 0xad, 0xbe, 0x17,
	0xbb, 0xd8, 0xab, 0x76, 0xd1, 0xfb, 0xab, 0x03, 0x83, 0x82, 0x86, 0x95, 0x1d, 0x6d, 0xee, 0xbe,
	0x84, 0xb5, 0xb7, 0x9a, 0xcd, 0x75, 0xd8, 0x04, 0x86, 0x17, 0x79, 0x2a, 0x32, 0x4c, 0x65, 0xa6,
	0xa2, 0xdb, 0xe2, 0xf4, 0x14, 0x4b, 0x7c, 0x1b, 0x01, 0x1c, 0x79, 0x29, 0xe5, 0xa9, 0x4c, 0xe6,
	0x6e, 0x87, 0xf5, 0xa1, 0x7d, 0xfc, 0xc1, 0x4f, 0xdd, 0x2e, 0xdb, 0x06, 0xf7, 0xb2, 0x48, 0xee,
	0x76, 0x8c, 0xdb, 0x63, 0x2f, 0x03, 0x3b, 0xc3, 0xc9, 0x93, 0x79, 0xb3, 0xa0, 0x8f, 0x61, 0x80,
	0x4b, 0xd0, 0xac, 0x83, 0xda, 0x32, 0x74, 0x04, 0x18, 0xe2, 0x81, 0xe3, 0xa9, 0x50, 0x3a, 0x4a,
	0xe6, 0xa7, 0xd1, 0x32, 0xd2, 0x2e, 0x78, 0xbf, 0xee, 0x42, 0xfb, 0xf0, 0xe8, 0xf4, 0x6b, 0xca,
	0x29, 0x7b, 0x1b, 0xc6, 0x51, 0xb2, 0x10, 0x59, 0xa4, 0x03, 0x3e, 0x8b, 0x95, 0x8d, 0x8f, 0x8e,
	0xce, 0x72, 0xe1, 0x8f, 0x6c, 0xcf, 0xe1, 0x2c, 0x56, 0xec, 0x00, 0x7a, 0xf3, 0x4c, 0xe6, 0xa9,
	0x39, 0xdf, 0x8e, 0x0e, 0x76, 0x1a, 0x16, 0x3e, 0x3c, 0x3a, 0xdd, 0x47, 0x8d, 0x7e, 0x82, 0x14,
	0xdf, 0x32, 0xd9, 0xbb, 0xd0, 0xa1, 0x49, 0x3b, 0x34, 0x62, 0xba, 0x76, 0xc4, 0xe1, 0xd1, 0xa9,
	0x4f, 0xac, 0x2a, 0x46, 0xbb, 0x6b, 0x62, 0xf4, 0x9f, 0x0e, 0x0c, 0xcb, 0x05, 0xca, 0x0d, 0x73,
	0xc8, 0x13, 0x4d, 0xd8, 0x79, 0x30, 0xb4, 0xfa, 0x8a, 0xb0, 0xf1, 0x19, 0x15, 0xcc, 0x5e, 0x87,
	0xbe, 0x15, 0xc8, 0xad, 0x0a, 0x46, 0x01, 0xb2, 0xb7, 0xa0, 0xf8, 0x66, 0x7e, 0x15, 0x0b, 0x53,
	0xae, 0xee, 0x18, 0x03, 0x3b, 0xb0, 0x9c, 0x61, 0xa9, 0xef, 0x52, 0x84, 0x60, 0xd3, 0xb8, 0x25,
	0xd5, 0x77, 0x53, 0xff, 0xad, 0xc4, 0xbe, 0x0f, 0x5b, 0xe5, 0xf2, 0xc1, 0x52, 0x2c, 0xaf, 0xb0,
	0xe6, 0x9a, 0x23, 0x80, 0x5b, 0x76, 0x9c, 0x19, 0x7c, 0xe7, 0xef, 0x0e, 0xf4, 0xad, 0x4d, 0xd8,
	0x23, 0x00, 0x9e, 0xa6, 0xf1, 0x2a, 0x58, 0x88, 0xcc, 0x9c, 0x56, 0xcb, 0xef, 0x21, 0xfc, 0x58,
	0x64, 0xa2, 0x22, 0xa9, 0xfc, 0xaa, 0xb9, 0x77, 0x86, 0x74, 0x91, 0x5f, 0xa9, 0xa6, 0x61, 0xda,
	0xeb, 0x0d, 0xf3, 0xa5, 0xb5, 0x73, 0x1b, 0xba, 0xb4, 0x99, 0x36, 0x6f, 0x19, 0xc1, 0xa0, 0x3c,
	0xd1, 0xf6, 0x4e, 0x60, 0x04, 0x53, 0x34, 0x93, 0x95, 0x4d, 0x59, 0xd4, 0xf6, 0xde, 0x07, 0xf8,
	0x19, 0x6e, 0x20, 0x1d, 0x2e, 0xd0, 0x6e, 0x51, 0x68, 0x12, 0xf7, 0xc4, 0xc7, 0x26, 0xce, 0x84,
	0xbb, 0xa7, 0x28, 0x4d, 0x0d, 0x7d, 0x23, 0x78, 0x21, 0xc0, 0x51, 0xb6, 0x4a, 0xf5, 0x85, 0xd0,
	0x79, 0x8a, 0xa3, 0x6e, 0xc4, 0x8a, 0x6c, 0x30, 0xf6, 0xb1, 0x49, 0xc5, 0x29, 0x8e, 0xb0, 0x36,
	0x25, 0x32, 0x99, 0x99, 0x8b, 0x22, 0x16, 0x27, 0xc2, 0x9e, 0x22, 0x84, 0x14, 0x45, 0x27, 0x5d,
	0x4b, 0x69, 0x1b, 0x8a, 0xc1, 0x88, 0xe2, 0xfd, 0xc7, 0x81, 0x07, 0xb6, 0x8a, 0x1e, 0xce, 0x30,
	0xb9, 0x9e, 0xc9, 0x30, 0xba, 0x5e, 0xe1, 0x5e, 0x72, 0x92, 0xad, 0x7f, 0x59, 0x09, 0xbf, 0x8f,
	0xca, 0xb0, 0xb9, 0x04, 0x50, 0xdb, 0x14, 0xd5, 0xa4, 0x3c, 0xfe, 0x4e, 0xfc, 0x42, 0x64, 0xc7,
	0x30, 0x94, 0xa9, 0xb0, 0x59, 0xbc, 0x43, 0x59, 0xe9, 0x7b, 0x8d, 0x08, 0x58, 0xb3, 0xf4, 0xfe,
	0xc7, 0xc5, 0x08, 0xbf, 0x1a, 0xec, 0xbd, 0x0b, 0xfd, 0xa2, 0xd8, 0x03, 0xf4, 0xcc, 0xf9, 0xdd,
	0x75, 0xd8, 0xc8, 0x38, 0x0b, 0xe6, 0x8d, 0x16, 0x66, 0x28, 0x4a, 0x41, 0x1d, 0x6f, 0x17, 0x86,
	0xe5, 0x2c, 0x98, 0x6d, 0x0e, 0xc3, 0xd0, 0x7d, 0x09, 0x07, 0x9a, 0x23, 0x9d, 0xeb, 0x78, 0xbf,
	0x80, 0x49, 0x63, 0xed, 0xaf, 0x38, 0x7d, 0x7d, 0x4d, 0x9a, 0xae, 0x2c, 0xd5, 0xae, 0x5b, 0xca,
	0xfb, 0x8b, 0x63, 0xd2, 0x15, 0x95, 0xeb, 0xf7, 0xa0, 0x6b, 0x8e, 0x9a, 0xce, 0x9a, 0xc4, 0x51,
	0xb0, 0xa8, 0xe1, 0x1b, 0xe2, 0x8e, 0x32, 0x1f, 0x53, 0xf7, 0x4a, 0x93, 0xb8, 0x0a, 0xaf, 0x2c,
	0xe2, 0xbf, 0x55, 0x2b, 0xbb, 0x78, 0x08, 0xe7, 0x4a, 0x07, 0x4a, 0x88, 0xe2, 0xf4, 0x39, 0x40,
	0xe0, 0x42, 0x88, 0x84, 0x0e, 0xe1, 0xd8, 0x69, 0x55, 0xb7, 0x4e, 0x3e, 0x42, 0xcc, 0xda, 0xd0,
	0xfb, 0xb7, 0x03, 0xa3, 0x67, 0x32, 0x9a, 0x89, 0x4b, 0x9e, 0xcd, 0x85, 0x66, 0x1b, 0xd0, 0x2a,
	0xef, 0x13, 0xad, 0x28, 0x64, 0x1f, 0x40, 0x5f, 0x53, 0x8f, 0xf1, 0xd5, 0xd1, 0xc1, 0x1b, 0x8d,
	0x0f, 0xa9, 0x0d, 0xdd, 0x37, 0x7f, 0x7e, 0xc1, 0xdf, 0xf9, 0x83, 0x03, 0x3d, 0x3b, 0x6b, 0xc3,
	0xd4, 0xed, 0xff, 0xc1, 0xd4, 0x65, 0x20, 0xb6, 0xeb, 0x81, 0xf8, 0x6a, 0x75, 0x63, 0xa9, 0xe7,
	0x4c, 0x73, 0x71, 0x79, 0x13, 0x06, 0xb3, 0x45, 0x14, 0x87, 0x99, 0x48, 0x9a, 0x39, 0xb5, 0x84,
	0x3d, 0x09, 0x9b, 0x55, 0x39, 0xa3, 0x40, 0xfd, 0xba, 0xfb, 0xd4, 0x9d, 0x1b, 0x9d, 0xd1, 0xb3,
	0x0e, 0xa1, 0x4e, 0xd7, 0x71, 0xae, 0x16, 0x36, 0xd7, 0x14, 0x3a, 0x11, 0xe6, 0xfd, 0x0a, 0xc6,
	0x47, 0x32, 0x14, 0xb3, 0xe2, 0x1d, 0x08, 0x8f, 0x2f, 0x71, 0xba, 0xe0, 0xb4, 0xc1, 0x5d, 0xdf,
	0x08, 0xb8, 0xbf, 0x57, 0x42, 0x73, 0x3a, 0x6a, 0x75, 0x7d, 0x6a, 0x63, 0xa5, 0x4a, 0x33, 0x71,
	0x2d, 0xb2, 0xc0, 0x0c, 0x40, 0x8f, 0x2b, 0x93, 0xb3, 0xe9, 0x39, 0xa4, 0xc1, 0xc5, 0x63, 0x4a,
	0xe7, 0xfe, 0x63, 0xca, 0x17, 0xbd, 0xea, 0xd2, 0xa1, 0xbe, 0xc2, 0xed, 0xbf, 0x03, 0xa0, 0x90,
	0x12, 0xc8, 0x24, 0xbe, 0x73, 0x66, 0x1c, 0x52, 0xc7, 0xc7, 0x49, 0xbc, 0x62, 0x1e, 0x8c, 0x67,
	0x55, 0x91, 0x36, 0x85, 0x71, 0xec, 0x37, 0x30, 0xf6, 0x23, 0x18, 0x5d, 0x67, 0x72, 0x19, 0x98,
	0xd4, 0x44, 0x3a, 0x8d, 0x0e, 0x5e, 0xbb, 0x17, 0x02, 0xa4, 0xd0, 0x3e, 0xfd, 0xfa, 0x80, 0x03,
	0x8e, 0x88, 0x5f, 0x0e, 0x37, 0x69, 0x8b, 0x76, 0xf1, 0x1b, 0x0d, 0x37, 0x49, 0xe2, 0xff, 0xe7,
	0x05, 0x87, 0xed, 0x57, 0xef, 0x85, 0x63, 0x32, 0xc2, 0x76, 0x33, 0xfa, 0x4c, 0x5f, 0xf5, 0x8a,
	0x78, 0xef, 0xd9, 0x6d, 0xb2, 0xe6, 0xd9, 0xad, 0x76, 0xd6, 0xdf, 0x30, 0x77, 0xaf, 0xe2, 0xac,
	0xff, 0x1a, 0x0c, 0xab, 0xb7, 0x8f, 0x4d, 0x13, 0x03, 0x25, 0x80, 0x87, 0x5b, 0x99, 0xc4, 0x51,
	0x22, 0x94, 0x98, 0x29, 0xba, 0x19, 0x4d, 0xfc, 0x1a, 0x82, 0xe7, 0xf7, 0x28, 0x8c, 0x4d, 0xef,
	0x96, 0x39, 0xbf, 0x17, 0x32, 0x7b, 0x1f, 0x98, 0xd2, 0x99, 0x4c, 0xe6, 0x41, 0xcd, 0x4f, 0xcc,
	0x9d, 0xa8, 0x70, 0xb1, 0x2d, 0x43, 0xa8, 0x1d, 0x00, 0x4b, 0x9f, 0x7e, 0x70, 0xcf, 0xa7, 0x77,
	0x7e, 0x0e, 0x5d, 0xe3, 0xce, 0xc5, 0x13, 0xa0, 0xb3, 0xe6, 0x09, 0xb0, 0xb5, 0xe6, 0x09, 0xb0,
	0xbd, 0xf6, 0x09, 0xb0, 0x53, 0x7f, 0x02, 0xf4, 0x3e, 0x77, 0x60, 0xe4, 0x8b, 0xcf, 0x72, 0xa1,
	0xf4, 0xe3, 0x58, 0x5e, 0xe1, 0x65, 0xd3, 0xc6, 0x48, 0x50, 0xdc, 0x5a, 0x4d, 0x1a, 0xdb, 0xb0,
	0xf0, 0xa5, 0xbd, 0xbc, 0xd6, 0x88, 0xc5, 0xa5, 0xb3, 0xd5, 0x20, 0x1e, 0xd9, 0xbb, 0xe7, 0x0f,
	0xe0, 0x41, 0x91, 0x6e, 0xea, 0xaf, 0x2c, 0xe6, 0x62, 0xc2, 0x6c, 0xd7, 0x93, 0xaa, 0xc7, 0xfb,
	0x97, 0x03, 0x63, 0xe3, 0xde, 0x47, 0x32, 0xb9, 0x8e, 0xe6, 0xf7, 0xdf, 0xaa, 0x9c, 0x6f, 0xf0,
	0x56, 0xd5, 0xba, 0xff, 0x56, 0xf5, 0x10, 0x80, 0xc7, 0xb1, 0x7c, 0x1e, 0x2c, 0xf4, 0x32, 0x36,
	0xc9, 0xcb, 0x1f, 0x12, 0x72, 0xac, 0x97, 0x31, 0x5e, 0xc7, 0xed, 0x8d, 0x27, 0x88, 0x45, 0x32,
	0xd7, 0x0b, 0x6b, 0xaa, 0x89, 0x45, 0x4f, 0x09, 0x64, 0xef, 0xc1, 0x76, 0xb4, 0x44, 0xd2, 0x1d,
	0xb2, 0x79, 0x76, 0x60, 0xd4, 0x77, 0xd6, 0x18, 0xd1, 0x78, 0x8e, 0xe9, 0xdd, 0x79, 0x8e, 0xb9,
	0x81, 0xc9, 0x45, 0x3e, 0x9f, 0x0b, 0xa5, 0xed, 0xd7, 0x7e, 0xf9, 0xc3, 0x39, 0x5e, 0xb9, 0xec,
	0x6b, 0x10, 0x8f, 0x4d, 0xd2, 0xf2, 0x6b, 0x08, 0x06, 0x59, 0x9a, 0xab, 0x45, 0xa0, 0x65, 0xa0,
	0x79, 0x7c, 0x63, 0xbf, 0x10, 0x10, 0xbb, 0x94, 0x97, 0x3c, 0xbe, 0x79, 0xdc, 0x3a, 0x76, 0xfe,
	0x1b, 0x00, 0x00, 0xff, 0xff, 0x85, 0xe0, 0xf0, 0x3c, 0xbf, 0x17, 0x00, 0x00,
}
